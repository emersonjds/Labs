import {useGlobalListeners as $fA3fN$useGlobalListeners, clamp as $fA3fN$clamp, mergeProps as $fA3fN$mergeProps, focusWithoutScrolling as $fA3fN$focusWithoutScrolling} from "@react-aria/utils";
import {useRef as $fA3fN$useRef, useCallback as $fA3fN$useCallback, useEffect as $fA3fN$useEffect} from "react";
import {useMove as $fA3fN$useMove, setInteractionModality as $fA3fN$setInteractionModality, useKeyboard as $fA3fN$useKeyboard} from "@react-aria/interactions";
import {useLabel as $fA3fN$useLabel} from "@react-aria/label";
import {useLocale as $fA3fN$useLocale} from "@react-aria/i18n";
import {useFocusable as $fA3fN$useFocusable} from "@react-aria/focus";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $bcca50147b47f54d$exports = {};

$parcel$export($bcca50147b47f54d$exports, "useSlider", () => $bcca50147b47f54d$export$56b2c08e277f365);

const $aa519ee6cf463259$export$7a8d2b02c9371cbf = new WeakMap();
function $aa519ee6cf463259$export$68e648cbec363a18(state, index) {
    let id = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);
    if (!id) throw new Error('Unknown slider state');
    return `${id}-${index}`;
}






function $bcca50147b47f54d$export$56b2c08e277f365(props, state, trackRef) {
    let { labelProps: labelProps , fieldProps: fieldProps  } = $fA3fN$useLabel(props);
    let isVertical = props.orientation === 'vertical';
    var _id;
    // Attach id of the label to the state so it can be accessed by useSliderThumb.
    $aa519ee6cf463259$export$7a8d2b02c9371cbf.set(state, (_id = labelProps.id) !== null && _id !== void 0 ? _id : fieldProps.id);
    let { direction: direction  } = $fA3fN$useLocale();
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $fA3fN$useGlobalListeners();
    // When the user clicks or drags the track, we want the motion to set and drag the
    // closest thumb.  Hence we also need to install useMove() on the track element.
    // Here, we keep track of which index is the "closest" to the drag start point.
    // It is set onMouseDown/onTouchDown; see trackProps below.
    const realTimeTrackDraggingIndex = $fA3fN$useRef(null);
    const stateRef = $fA3fN$useRef(null);
    stateRef.current = state;
    const reverseX = direction === 'rtl';
    const currentPosition = $fA3fN$useRef(null);
    const { moveProps: moveProps  } = $fA3fN$useMove({
        onMoveStart () {
            currentPosition.current = null;
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY  }) {
            let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;
            if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;
            let delta = isVertical ? deltaY : deltaX;
            if (isVertical || reverseX) delta = -delta;
            currentPosition.current += delta;
            if (realTimeTrackDraggingIndex.current != null && trackRef.current) {
                const percent = $fA3fN$clamp(currentPosition.current / size, 0, 1);
                stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);
            }
        },
        onMoveEnd () {
            if (realTimeTrackDraggingIndex.current != null) {
                stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);
                realTimeTrackDraggingIndex.current = null;
            }
        }
    });
    let currentPointer = $fA3fN$useRef(undefined);
    let onDownTrack = (e, id, clientX, clientY)=>{
        // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.
        if (trackRef.current && !props.isDisabled && state.values.every((_, i)=>!state.isThumbDragging(i)
        )) {
            let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;
            // Find the closest thumb
            const trackPosition = trackRef.current.getBoundingClientRect()[isVertical ? 'top' : 'left'];
            const clickPosition = isVertical ? clientY : clientX;
            const offset = clickPosition - trackPosition;
            let percent = offset / size;
            if (direction === 'rtl' || isVertical) percent = 1 - percent;
            let value = state.getPercentValue(percent);
            // to find the closet thumb we split the array based on the first thumb position to the "right/end" of the click.
            let closestThumb;
            let split = state.values.findIndex((v)=>value - v < 0
            );
            if (split === 0) closestThumb = split;
            else if (split === -1) closestThumb = state.values.length - 1;
            else {
                let lastLeft = state.values[split - 1];
                let firstRight = state.values[split];
                // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one
                if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;
                else closestThumb = split;
            }
            // Confirm that the found closest thumb is editable, not disabled, and move it
            if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {
                // Don't unfocus anything
                e.preventDefault();
                realTimeTrackDraggingIndex.current = closestThumb;
                state.setFocusedThumb(closestThumb);
                currentPointer.current = id;
                state.setThumbDragging(realTimeTrackDraggingIndex.current, true);
                state.setThumbValue(closestThumb, value);
                addGlobalListener(window, 'mouseup', onUpTrack, false);
                addGlobalListener(window, 'touchend', onUpTrack, false);
                addGlobalListener(window, 'pointerup', onUpTrack, false);
            } else realTimeTrackDraggingIndex.current = null;
        }
    };
    let onUpTrack = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            if (realTimeTrackDraggingIndex.current != null) {
                state.setThumbDragging(realTimeTrackDraggingIndex.current, false);
                realTimeTrackDraggingIndex.current = null;
            }
            removeGlobalListener(window, 'mouseup', onUpTrack, false);
            removeGlobalListener(window, 'touchend', onUpTrack, false);
            removeGlobalListener(window, 'pointerup', onUpTrack, false);
        }
    };
    if (labelProps.htmlFor) {
        // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS
        // causes this to override the `aria-labelledby` on the thumb. This causes the first
        // thumb to only be announced as the slider label rather than its individual name as well.
        // See https://bugs.webkit.org/show_bug.cgi?id=172464.
        delete labelProps.htmlFor;
        labelProps.onClick = ()=>{
            var // Safari does not focus <input type="range"> elements when clicking on an associated <label>,
            // so do it manually. In addition, make sure we show the focus ring.
            ref;
            (ref = document.getElementById($aa519ee6cf463259$export$68e648cbec363a18(state, 0))) === null || ref === void 0 ? void 0 : ref.focus();
            $fA3fN$setInteractionModality('keyboard');
        };
    }
    return {
        labelProps: labelProps,
        // The root element of the Slider will have role="group" to group together
        // all the thumb inputs in the Slider.  The label of the Slider will
        // be used to label the group.
        groupProps: {
            role: 'group',
            ...fieldProps
        },
        trackProps: $fA3fN$mergeProps({
            onMouseDown (e) {
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onDownTrack(e, undefined, e.clientX, e.clientY);
            },
            onPointerDown (e) {
                if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;
                onDownTrack(e, e.pointerId, e.clientX, e.clientY);
            },
            onTouchStart (e) {
                onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }, moveProps),
        outputProps: {
            htmlFor: state.values.map((_, index)=>$aa519ee6cf463259$export$68e648cbec363a18(state, index)
            ).join(' '),
            'aria-live': 'off'
        }
    };
}


var $47b897dc8cdb026b$exports = {};

$parcel$export($47b897dc8cdb026b$exports, "useSliderThumb", () => $47b897dc8cdb026b$export$8d15029008292ae);







function $47b897dc8cdb026b$export$8d15029008292ae(opts, state) {
    let { index: index , isRequired: isRequired , isDisabled: isDisabled , validationState: validationState , trackRef: trackRef , inputRef: inputRef  } = opts;
    let isVertical = opts.orientation === 'vertical';
    let { direction: direction  } = $fA3fN$useLocale();
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $fA3fN$useGlobalListeners();
    let labelId = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);
    var ref1;
    const { labelProps: labelProps , fieldProps: fieldProps  } = $fA3fN$useLabel({
        ...opts,
        id: $aa519ee6cf463259$export$68e648cbec363a18(state, index),
        'aria-labelledby': `${labelId} ${(ref1 = opts['aria-labelledby']) !== null && ref1 !== void 0 ? ref1 : ''}`.trim()
    });
    const value = state.values[index];
    const focusInput = $fA3fN$useCallback(()=>{
        if (inputRef.current) $fA3fN$focusWithoutScrolling(inputRef.current);
    }, [
        inputRef
    ]);
    const isFocused = state.focusedThumb === index;
    $fA3fN$useEffect(()=>{
        if (isFocused) focusInput();
    }, [
        isFocused,
        focusInput
    ]);
    const stateRef = $fA3fN$useRef(null);
    stateRef.current = state;
    let reverseX = direction === 'rtl';
    let currentPosition = $fA3fN$useRef(null);
    let { keyboardProps: keyboardProps  } = $fA3fN$useKeyboard({
        onKeyDown (e) {
            let { getThumbMaxValue: getThumbMaxValue , getThumbMinValue: getThumbMinValue , decrementThumb: decrementThumb , incrementThumb: incrementThumb , setThumbValue: setThumbValue , setThumbDragging: setThumbDragging , pageSize: pageSize  } = stateRef.current;
            // these are the cases that useMove or useSlider don't handle
            if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {
                e.continuePropagation();
                return;
            }
            // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.
            e.preventDefault();
            // remember to set this so that onChangeEnd is fired
            setThumbDragging(index, true);
            switch(e.key){
                case 'PageUp':
                    incrementThumb(index, pageSize);
                    break;
                case 'PageDown':
                    decrementThumb(index, pageSize);
                    break;
                case 'Home':
                    setThumbValue(index, getThumbMinValue(index));
                    break;
                case 'End':
                    setThumbValue(index, getThumbMaxValue(index));
                    break;
            }
            setThumbDragging(index, false);
        }
    });
    let { moveProps: moveProps  } = $fA3fN$useMove({
        onMoveStart () {
            currentPosition.current = null;
            stateRef.current.setThumbDragging(index, true);
        },
        onMove ({ deltaX: deltaX , deltaY: deltaY , pointerType: pointerType , shiftKey: shiftKey  }) {
            const { getThumbPercent: getThumbPercent , setThumbPercent: setThumbPercent , decrementThumb: decrementThumb , incrementThumb: incrementThumb , step: step , pageSize: pageSize  } = stateRef.current;
            let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;
            if (currentPosition.current == null) currentPosition.current = getThumbPercent(index) * size;
            if (pointerType === 'keyboard') {
                if (deltaX > 0 && reverseX || deltaX < 0 && !reverseX || deltaY > 0) decrementThumb(index, shiftKey ? pageSize : step);
                else incrementThumb(index, shiftKey ? pageSize : step);
            } else {
                let delta = isVertical ? deltaY : deltaX;
                if (isVertical || reverseX) delta = -delta;
                currentPosition.current += delta;
                setThumbPercent(index, $fA3fN$clamp(currentPosition.current / size, 0, 1));
            }
        },
        onMoveEnd () {
            stateRef.current.setThumbDragging(index, false);
        }
    });
    // Immediately register editability with the state
    state.setThumbEditable(index, !isDisabled);
    const { focusableProps: focusableProps  } = $fA3fN$useFocusable($fA3fN$mergeProps(opts, {
        onFocus: ()=>state.setFocusedThumb(index)
        ,
        onBlur: ()=>state.setFocusedThumb(undefined)
    }), inputRef);
    let currentPointer = $fA3fN$useRef(undefined);
    let onDown = (id)=>{
        focusInput();
        currentPointer.current = id;
        state.setThumbDragging(index, true);
        addGlobalListener(window, 'mouseup', onUp, false);
        addGlobalListener(window, 'touchend', onUp, false);
        addGlobalListener(window, 'pointerup', onUp, false);
    };
    let onUp = (e)=>{
        var ref;
        var _pointerId;
        let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;
        if (id === currentPointer.current) {
            focusInput();
            state.setThumbDragging(index, false);
            removeGlobalListener(window, 'mouseup', onUp, false);
            removeGlobalListener(window, 'touchend', onUp, false);
            removeGlobalListener(window, 'pointerup', onUp, false);
        }
    };
    // We install mouse handlers for the drag motion on the thumb div, but
    // not the key handler for moving the thumb with the slider.  Instead,
    // we focus the range input, and let the browser handle the keyboard
    // interactions; we then listen to input's onChange to update state.
    return {
        inputProps: $fA3fN$mergeProps(focusableProps, fieldProps, {
            type: 'range',
            tabIndex: !isDisabled ? 0 : undefined,
            min: state.getThumbMinValue(index),
            max: state.getThumbMaxValue(index),
            step: state.step,
            value: value,
            disabled: isDisabled,
            'aria-orientation': opts.orientation,
            'aria-valuetext': state.getThumbValueLabel(index),
            'aria-required': isRequired || undefined,
            'aria-invalid': validationState === 'invalid' || undefined,
            'aria-errormessage': opts['aria-errormessage'],
            onChange: (e)=>{
                stateRef.current.setThumbValue(index, parseFloat(e.target.value));
            }
        }),
        thumbProps: !isDisabled ? $fA3fN$mergeProps(keyboardProps, moveProps, {
            onMouseDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onDown();
            },
            onPointerDown: (e)=>{
                if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;
                onDown(e.pointerId);
            },
            onTouchStart: (e)=>{
                onDown(e.changedTouches[0].identifier);
            }
        }) : {
        },
        labelProps: labelProps
    };
}




export {$bcca50147b47f54d$export$56b2c08e277f365 as useSlider, $47b897dc8cdb026b$export$8d15029008292ae as useSliderThumb};
//# sourceMappingURL=module.js.map
