{"version":3,"sources":["utils.ts"],"names":["extractProps","props","theme","componentTheme","currentBreakpoint","newProps","property","themePropertyMap","propValues","extractPropertyFromFunction","nestedProp","shadowProps","resolveValueWithBreakpoint","breakpoints","filterDefaultProps","defaultProps","resultProps","Object","keys","funcProps","isNested","some","key","mergeUnderscoreProps","_props","filter","propName","startsWith","forEach","bg","backgroundColor","textColor","color","values","breakpointTheme","calculateProps","colorModeProps","windowWidth","componentBaseStyle","baseStyle","objValue","srcValue","variant","variants","colorScheme","variantProps","extractedProps"],"mappings":"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","sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport {\n  getClosestBreakpoint,\n  findLastValidBreakpoint,\n  hasValidBreakpointFormat,\n  extractInObject,\n} from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n\n/*\n Extract props from theme props and omit those from props\n*/\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\nexport function extractProps(\n  props: any,\n  theme: any,\n  {},\n  componentTheme: any,\n  currentBreakpoint: number\n) {\n  let newProps: any = {};\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(\n        property,\n        props,\n        theme,\n        componentTheme\n      );\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(\n            theme,\n            `${themePropertyMap[nestedProp]}.${propValues[nestedProp]}`,\n            propValues[nestedProp]\n          );\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps, ...shadowProps };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(\n          props[property],\n          theme.breakpoints,\n          currentBreakpoint,\n          property\n        );\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(\n        props[property],\n        theme.breakpoints,\n        currentBreakpoint,\n        property\n      );\n    }\n  }\n  return cloneDeep(newProps);\n}\n\n/*\nRemove props from defaultProps that are already present in props\n*/\nfunction filterDefaultProps(props: any, defaultProps: any) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\nexport const extractPropertyFromFunction = (\n  property: string,\n  props: any,\n  theme: any,\n  componentTheme: any\n) => {\n  let propValues;\n  // Check if the entry in the theme is a function then calling it with all theme and props as params\n  if (\n    componentTheme &&\n    typeof componentTheme[themePropertyMap[property]] === 'function'\n  ) {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props,\n    });\n    // Check if returned object from componentTheme is a nested object\n    let isNested: boolean = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    // If the returned value is nested object then find the property value in it, otherwise return the whole object\n    propValues = isNested\n      ? { ...get(funcProps, `${props[property]}`) }\n      : { ...funcProps };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(\n      componentTheme,\n      `${themePropertyMap[property]}.${props[property]}`\n    );\n  }\n  return propValues;\n};\n\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\nexport function mergeUnderscoreProps(newProps: any, props: any) {\n  const _props = Object.keys(newProps).filter((propName) =>\n    propName.startsWith('_')\n  );\n  _props.forEach((propName: string) => {\n    // Adding color based on bg contrast if no color is given\n    const bg = newProps.bg ?? newProps.backgroundColor;\n    const textColor = bg\n      ? {\n          color: useContrastText(\n            bg,\n            newProps[propName]?.color ?? props[propName]?.color\n          ),\n        }\n      : {};\n    // Overriding calculated props with user added props\n    newProps[propName] = {\n      ...textColor,\n      ...newProps[propName],\n      ...props[propName],\n    };\n  });\n  return newProps;\n}\n\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\nexport const resolveValueWithBreakpoint = (\n  values: any,\n  breakpointTheme: any,\n  currentBreakpoint: number,\n  property: any\n) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\nexport function calculateProps(\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  props: any,\n  windowWidth: any\n) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n  if (!props) {\n    props = {};\n  }\n\n  let newProps: any;\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(\n      filterDefaultProps(props, componentTheme.defaultProps),\n      theme,\n      colorModeProps,\n      componentTheme,\n      currentBreakpoint\n    );\n    // Extracting props from base style\n    let componentBaseStyle =\n      typeof componentTheme.baseStyle !== 'function'\n        ? componentTheme.baseStyle\n        : componentTheme.baseStyle({\n            theme,\n            ...newProps,\n            ...props,\n            ...colorModeProps,\n          });\n    newProps = mergeWith(\n      newProps,\n      componentBaseStyle,\n      // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      }\n    );\n\n    const variant =\n      props.variant || get(componentTheme, 'defaultProps.variant');\n    // Extracting props from variant\n    if (\n      variant &&\n      componentTheme.variants &&\n      componentTheme.variants[variant]\n    ) {\n      const colorScheme =\n        props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({\n        ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps,\n      });\n      variantProps = extractProps(\n        variantProps,\n        theme,\n        colorModeProps,\n        componentTheme,\n        currentBreakpoint\n      );\n      // added this to handle order of props\n      newProps = mergeWith(\n        newProps,\n        variantProps,\n        // @ts-ignore\n        (objValue, srcValue, key) => {\n          if (!isNil(objValue)) {\n            delete newProps[key];\n          }\n        }\n      );\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n  // Extracting props from normal props\n  let extractedProps = extractProps(\n    props,\n    theme,\n    colorModeProps,\n    componentTheme,\n    currentBreakpoint\n  );\n  // added this to handle order of props\n  // @ts-ignore\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n"]}