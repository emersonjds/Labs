{"version":3,"sources":["SkeletonText.tsx"],"names":["SkeletonText","props","ref","children","startColor","endColor","lines","isLoaded","_line","resolvedProps","computedChildren","i","push"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;AAGA,MAAMA,YAAY,GAAG,CAEnBC,KAFmB,EAGnBC,GAHmB,KAIhB;AACH;AACA,QAAM;AACJC,IAAAA,QADI;AAEJC,IAAAA,UAFI;AAGJC,IAAAA,QAHI;AAIJC,IAAAA,KAJI;AAKJC,IAAAA,QALI;AAMJC,IAAAA,KANI;AAOJ,OAAGC;AAPC,MAQF,+BAAmB,cAAnB,EAAmCR,KAAnC,CARJ;AAUA,QAAMS,gBAAgB,GAAG,EAAzB,CAZG,CAaH;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAApB,EAA2BK,CAAC,EAA5B,EAAgC;AAC9B;AACA,QAAIA,CAAC,KAAKL,KAAK,GAAG,CAAd,IAAmBA,KAAK,KAAK,CAAjC,EAAoC;AAClCI,MAAAA,gBAAgB,CAACE,IAAjB;AAAA;AACE;AACA,mCAAC,iBAAD;AACE,QAAA,GAAG,EAAED,CADP;AAEE,QAAA,QAAQ,EAAEN,QAFZ;AAGE,QAAA,UAAU,EAAED,UAHd;AAIE,QAAA,CAAC,EAAC;AAJJ,SAKMI,KALN,EAFF;AAUD,KAXD,MAYEE,gBAAgB,CAACE,IAAjB,eACE,6BAAC,iBAAD;AACE,MAAA,GAAG,EAAED,CADP;AAEE,MAAA,QAAQ,EAAEN,QAFZ;AAGE,MAAA,UAAU,EAAED;AAHd,OAIMI,KAJN,EADF;AAQH;;AACD,SAAOD,QAAQ,GACbJ,QADa,gBAGb,6BAAC,YAAD,eAAWM,aAAX;AAA0B,IAAA,GAAG,EAAEP;AAA/B,MACGQ,gBADH,CAHF;AAOD,CAhDD;;4BAkDe,+BAAK,uBAAWV,YAAX,CAAL,C","sourcesContent":["import React, { memo, forwardRef } from 'react';\nimport { usePropsResolution } from '../../../hooks';\nimport { Stack } from '../../primitives/Stack';\nimport Skeleton from './Skeleton';\nimport type { ISkeletonTextProps } from './types';\n\nconst SkeletonText = (\n  //@ts-ignore\n  props: ISkeletonTextProps,\n  ref: any\n) => {\n  // const { children, ...props } = allProps;\n  const {\n    children,\n    startColor,\n    endColor,\n    lines,\n    isLoaded,\n    _line,\n    ...resolvedProps\n  } = usePropsResolution('SkeletonText', props);\n\n  const computedChildren = [];\n  //generating an array of skeleton components (same length as noOfLines)\n  for (let i = 0; i < lines; i++) {\n    //check for last line (to change the width of last line)\n    if (i === lines - 1 && lines !== 1) {\n      computedChildren.push(\n        //Using Skeleton component with required props\n        <Skeleton\n          key={i}\n          endColor={endColor}\n          startColor={startColor}\n          w=\"75%\"\n          {..._line}\n        />\n      );\n    } else\n      computedChildren.push(\n        <Skeleton\n          key={i}\n          endColor={endColor}\n          startColor={startColor}\n          {..._line}\n        />\n      );\n  }\n  return isLoaded ? (\n    children\n  ) : (\n    <Stack {...resolvedProps} ref={ref}>\n      {computedChildren}\n    </Stack>\n  );\n};\n\nexport default memo(forwardRef(SkeletonText));\n"]}