Object.defineProperty(exports, '__esModule', {
  value: true
});

var graphql = require('graphql');

var fetchSource = require('./3ada59d5.js');

var wonka = require('wonka');

function collectTypes(obj, types) {
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      collectTypes(obj[i], types);
    }
  } else if (typeof obj === 'object' && obj !== null) {
    for (var key in obj) {
      if (key === '__typename' && typeof obj[key] === 'string') {
        types[obj[key]] = 0;
      } else {
        collectTypes(obj[key], types);
      }
    }
  }

  return types;
}

function collectTypesFromResponse(response) {
  return Object.keys(collectTypes(response, {}));
}

var formatNode = function (node) {
  if (node.selectionSet && !node.selectionSet.selections.some(function (node) {
    return node.kind === graphql.Kind.FIELD && node.name.value === '__typename' && !node.alias;
  })) {
    return fetchSource._extends({}, node, {
      selectionSet: fetchSource._extends({}, node.selectionSet, {
        selections: node.selectionSet.selections.concat([{
          kind: graphql.Kind.FIELD,
          name: {
            kind: graphql.Kind.NAME,
            value: '__typename'
          }
        }])
      })
    });
  }
};

var formattedDocs = new Map();

function formatDocument(node) {
  var query = fetchSource.keyDocument(node);
  var result = formattedDocs.get(query.__key);

  if (!result) {
    result = graphql.visit(query, {
      Field: formatNode,
      InlineFragment: formatNode
    }); // Ensure that the hash of the resulting document won't suddenly change
    // we are marking __key as non-enumerable so when external exchanges use visit
    // to manipulate a document we won't restore the previous query due to the __key
    // property.

    Object.defineProperty(result, '__key', {
      value: query.__key,
      enumerable: false
    });
    formattedDocs.set(query.__key, result);
  }

  return result;
}

function maskTypename(data) {
  if (!data || typeof data !== 'object') {
    return data;
  }

  return Object.keys(data).reduce(function (acc, key) {
    var value = data[key];

    if (key === '__typename') {
      Object.defineProperty(acc, '__typename', {
        enumerable: false,
        value: value
      });
    } else if (Array.isArray(value)) {
      acc[key] = value.map(maskTypename);
    } else if (value && typeof value === 'object' && '__typename' in value) {
      acc[key] = maskTypename(value);
    } else {
      acc[key] = value;
    }

    return acc;
  }, Array.isArray(data) ? [] : {});
}

function withPromise(source$) {
  source$.toPromise = function () {
    return new Promise(function (resolve) {
      var subscription = wonka.subscribe(function (result) {
        if (!result.stale && !result.hasNext) {
          Promise.resolve().then(function () {
            subscription.unsubscribe();
            resolve(result);
          });
        }
      })(source$);
    });
  };

  return source$;
}

function makeOperation(kind, request, context) {
  if (!context) {
    context = request.context;
  }

  return {
    key: request.key,
    query: request.query,
    variables: request.variables,
    kind: kind,
    context: context
  };
}
/** Spreads the provided metadata to the source operation's meta property in context.  */


function addMetadata(operation, meta) {
  return makeOperation(operation.kind, operation, fetchSource._extends({}, operation.context, {
    meta: fetchSource._extends({}, operation.context.meta, meta)
  }));
}

function noop() {
  /* noop */
}

function applyDefinitions(fragmentNames, target, source) {
  for (var i = 0; i < source.length; i++) {
    if (source[i].kind === graphql.Kind.FRAGMENT_DEFINITION) {
      var name = source[i].name.value;
      var value = fetchSource.stringifyDocument(source[i]); // Fragments will be deduplicated according to this Map

      if (!fragmentNames.has(name)) {
        fragmentNames.set(name, value);
        target.push(source[i]);
      } else if (process.env.NODE_ENV !== 'production' && fragmentNames.get(name) !== value) {
        // Fragments with the same names is expected to have the same contents
        console.warn('[WARNING: Duplicate Fragment] A fragment with name `' + name + '` already exists in this document.\n' + 'While fragment names may not be unique across your source, each name must be unique per document.');
      }
    } else {
      target.push(source[i]);
    }
  }
}

function gql()
/* arguments */
{
  var arguments$1 = arguments;
  var fragmentNames = new Map();
  var definitions = [];
  var interpolations = []; // Apply the entire tagged template body's definitions

  var body = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || '';

  for (var i = 1; i < arguments.length; i++) {
    var value = arguments$1[i];

    if (value && value.definitions) {
      interpolations.push.apply(interpolations, value.definitions);
    } else {
      body += value;
    }

    body += arguments$1[0][i];
  } // Apply the tag's body definitions


  applyDefinitions(fragmentNames, definitions, fetchSource.keyDocument(body).definitions); // Copy over each interpolated document's definitions

  applyDefinitions(fragmentNames, definitions, interpolations);
  return fetchSource.keyDocument({
    kind: graphql.Kind.DOCUMENT,
    definitions: definitions
  });
}

function shouldSkip(ref) {
  var kind = ref.kind;
  return kind !== 'mutation' && kind !== 'query';
}

function cacheExchange(ref) {
  var forward = ref.forward;
  var client = ref.client;
  var dispatchDebug = ref.dispatchDebug;
  var resultCache = new Map();
  var operationCache = Object.create(null); // Adds unique typenames to query (for invalidating cache entries)

  function mapTypeNames(operation) {
    var formattedOperation = makeOperation(operation.kind, operation);
    formattedOperation.query = formatDocument(operation.query);
    return formattedOperation;
  }

  function isOperationCached(operation) {
    var key = operation.key;
    var kind = operation.kind;
    var requestPolicy = operation.context.requestPolicy;
    return kind === 'query' && requestPolicy !== 'network-only' && (requestPolicy === 'cache-only' || resultCache.has(key));
  }

  return function (ops$) {
    var sharedOps$ = wonka.share(ops$);
    var cachedOps$ = wonka.map(function (operation) {
      var cachedResult = resultCache.get(operation.key);
      process.env.NODE_ENV !== 'production' ? dispatchDebug(fetchSource._extends({}, {
        operation: operation
      }, cachedResult ? {
        type: 'cacheHit',
        message: 'The result was successfully retried from the cache'
      } : {
        type: 'cacheMiss',
        message: 'The result could not be retrieved from the cache'
      })) : undefined;

      var result = fetchSource._extends({}, cachedResult, {
        operation: addMetadata(operation, {
          cacheOutcome: cachedResult ? 'hit' : 'miss'
        })
      });

      if (operation.context.requestPolicy === 'cache-and-network') {
        result.stale = true;
        reexecuteOperation(client, operation);
      }

      return result;
    })(wonka.filter(function (op) {
      return !shouldSkip(op) && isOperationCached(op);
    })(sharedOps$));
    var forwardedOps$ = wonka.tap(function (response) {
      var operation = response.operation;

      if (!operation) {
        return;
      }

      var typenames = collectTypesFromResponse(response.data).concat(operation.context.additionalTypenames || []); // Invalidates the cache given a mutation's response

      if (response.operation.kind === 'mutation') {
        var pendingOperations = new Set();
        process.env.NODE_ENV !== 'production' ? dispatchDebug({
          type: 'cacheInvalidation',
          message: "The following typenames have been invalidated: " + typenames,
          operation: operation,
          data: {
            typenames: typenames,
            response: response
          },
          "source": "cacheExchange"
        }) : undefined;

        for (var i = 0; i < typenames.length; i++) {
          var typeName = typenames[i];
          var operations = operationCache[typeName] || (operationCache[typeName] = new Set());
          operations.forEach(function (key) {
            pendingOperations.add(key);
          });
          operations.clear();
        }

        pendingOperations.forEach(function (key) {
          if (resultCache.has(key)) {
            operation = resultCache.get(key).operation;
            resultCache.delete(key);
            reexecuteOperation(client, operation);
          }
        }); // Mark typenames on typenameInvalidate for early invalidation
      } else if (operation.kind === 'query' && response.data) {
        resultCache.set(operation.key, response);

        for (var i$1 = 0; i$1 < typenames.length; i$1++) {
          var typeName$1 = typenames[i$1];
          var operations$1 = operationCache[typeName$1] || (operationCache[typeName$1] = new Set());
          operations$1.add(operation.key);
        }
      }
    })(forward(wonka.filter(function (op) {
      return op.kind !== 'query' || op.context.requestPolicy !== 'cache-only';
    })(wonka.map(function (op) {
      return addMetadata(op, {
        cacheOutcome: 'miss'
      });
    })(wonka.merge([wonka.map(mapTypeNames)(wonka.filter(function (op) {
      return !shouldSkip(op) && !isOperationCached(op);
    })(sharedOps$)), wonka.filter(function (op) {
      return shouldSkip(op);
    })(sharedOps$)])))));
    return wonka.merge([cachedOps$, forwardedOps$]);
  };
}

function reexecuteOperation(client, operation) {
  return client.reexecuteOperation(makeOperation(operation.kind, operation, fetchSource._extends({}, operation.context, {
    requestPolicy: 'network-only'
  })));
}
/** Serialize an OperationResult to plain JSON */


function serializeResult(ref, includeExtensions) {
  var hasNext = ref.hasNext;
  var data = ref.data;
  var extensions = ref.extensions;
  var error = ref.error;
  var result = {};

  if (data !== undefined) {
    result.data = JSON.stringify(data);
  }

  if (includeExtensions && extensions !== undefined) {
    result.extensions = JSON.stringify(extensions);
  }

  if (hasNext) {
    result.hasNext = true;
  }

  if (error) {
    result.error = {
      graphQLErrors: error.graphQLErrors.map(function (error) {
        if (!error.path && !error.extensions) {
          return error.message;
        }

        return {
          message: error.message,
          path: error.path,
          extensions: error.extensions
        };
      })
    };

    if (error.networkError) {
      result.error.networkError = '' + error.networkError;
    }
  }

  return result;
}

function deserializeResult(operation, result, includeExtensions) {
  return {
    operation: operation,
    data: result.data ? JSON.parse(result.data) : undefined,
    extensions: includeExtensions && result.extensions ? JSON.parse(result.extensions) : undefined,
    error: result.error ? new fetchSource.CombinedError({
      networkError: result.error.networkError ? new Error(result.error.networkError) : undefined,
      graphQLErrors: result.error.graphQLErrors
    }) : undefined,
    hasNext: result.hasNext
  };
}

var revalidated = new Set();
/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */

function ssrExchange(params) {
  var staleWhileRevalidate = !!(params && params.staleWhileRevalidate);
  var includeExtensions = !!(params && params.includeExtensions);
  var data = {}; // On the client-side, we delete results from the cache as they're resolved
  // this is delayed so that concurrent queries don't delete each other's data

  var invalidateQueue = [];

  function invalidate(result) {
    invalidateQueue.push(result.operation.key);

    if (invalidateQueue.length === 1) {
      Promise.resolve().then(function () {
        var key;

        while (key = invalidateQueue.shift()) {
          data[key] = null;
        }
      });
    }
  } // The SSR Exchange is a temporary cache that can populate results into data for suspense
  // On the client it can be used to retrieve these temporary results from a rehydrated cache


  var ssr = function (ref) {
    var client = ref.client;
    var forward = ref.forward;
    return function (ops$) {
      // params.isClient tells us whether we're on the client-side
      // By default we assume that we're on the client if suspense-mode is disabled
      var isClient = params && typeof params.isClient === 'boolean' ? !!params.isClient : !client.suspense;
      var sharedOps$ = wonka.share(ops$);
      var forwardedOps$ = forward(wonka.filter(function (operation) {
        return !data[operation.key] || !!data[operation.key].hasNext;
      })(sharedOps$)); // NOTE: Since below we might delete the cached entry after accessing
      // it once, cachedOps$ needs to be merged after forwardedOps$

      var cachedOps$ = wonka.map(function (op) {
        var serialized = data[op.key];
        var result = deserializeResult(op, serialized, includeExtensions);

        if (staleWhileRevalidate && !revalidated.has(op.key)) {
          result.stale = true;
          revalidated.add(op.key);
          reexecuteOperation(client, op);
        }

        return result;
      })(wonka.filter(function (operation) {
        return !!data[operation.key] && operation.context.requestPolicy !== 'network-only';
      })(sharedOps$));

      if (!isClient) {
        // On the server we cache results in the cache as they're resolved
        forwardedOps$ = wonka.tap(function (result) {
          var operation = result.operation;

          if (operation.kind !== 'mutation') {
            var serialized = serializeResult(result, includeExtensions);
            data[operation.key] = serialized;
          }
        })(forwardedOps$);
      } else {
        // On the client we delete results from the cache as they're resolved
        cachedOps$ = wonka.tap(invalidate)(cachedOps$);
      }

      return wonka.merge([forwardedOps$, cachedOps$]);
    };
  };

  ssr.restoreData = function (restore) {
    for (var key in restore) {
      // We only restore data that hasn't been previously invalidated
      if (data[key] !== null) {
        data[key] = restore[key];
      }
    }
  };

  ssr.extractData = function () {
    var result = {};

    for (var key in data) {
      if (data[key] != null) {
        result[key] = data[key];
      }
    }

    return result;
  };

  if (params && params.initialState) {
    ssr.restoreData(params.initialState);
  }

  return ssr;
}

function subscriptionExchange(ref) {
  var forwardSubscription = ref.forwardSubscription;
  var enableAllOperations = ref.enableAllOperations;
  var isSubscriptionOperation = ref.isSubscriptionOperation;
  return function (ref) {
    var client = ref.client;
    var forward = ref.forward;

    function createSubscriptionSource(operation) {
      // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional
      var observableish = forwardSubscription({
        key: operation.key.toString(36),
        query: graphql.print(operation.query),
        variables: operation.variables,
        context: fetchSource._extends({}, operation.context)
      });
      return wonka.make(function (ref) {
        var next = ref.next;
        var complete = ref.complete;
        var isComplete = false;
        var sub;
        Promise.resolve().then(function () {
          if (isComplete) {
            return;
          }

          sub = observableish.subscribe({
            next: function (result) {
              return next(fetchSource.makeResult(operation, result));
            },
            error: function (err) {
              return next(fetchSource.makeErrorResult(operation, err));
            },
            complete: function () {
              if (!isComplete) {
                isComplete = true;

                if (operation.kind === 'subscription') {
                  client.reexecuteOperation(makeOperation('teardown', operation, operation.context));
                }

                complete();
              }
            }
          });
        });
        return function () {
          isComplete = true;

          if (sub) {
            sub.unsubscribe();
          }
        };
      });
    }

    var isSubscriptionOperationFn = isSubscriptionOperation || function (operation) {
      var kind = operation.kind;
      return kind === 'subscription' || !!enableAllOperations && (kind === 'query' || kind === 'mutation');
    };

    return function (ops$) {
      var sharedOps$ = wonka.share(ops$);
      var subscriptionResults$ = wonka.mergeMap(function (operation) {
        var key = operation.key;
        var teardown$ = wonka.filter(function (op) {
          return op.kind === 'teardown' && op.key === key;
        })(sharedOps$);
        return wonka.takeUntil(teardown$)(createSubscriptionSource(operation));
      })(wonka.filter(isSubscriptionOperationFn)(sharedOps$));
      var forward$ = forward(wonka.filter(function (op) {
        return !isSubscriptionOperationFn(op);
      })(sharedOps$));
      return wonka.merge([subscriptionResults$, forward$]);
    };
  };
}

function debugExchange(ref) {
  var forward = ref.forward;

  if (process.env.NODE_ENV === 'production') {
    return function (ops$) {
      return forward(ops$);
    };
  } else {
    return function (ops$) {
      return wonka.tap(function (result) {
        return console.log('[Exchange debug]: Completed operation: ', result);
      })(forward( // eslint-disable-next-line no-console
      wonka.tap(function (op) {
        return console.log('[Exchange debug]: Incoming operation: ', op);
      })(ops$)));
    };
  }
}
/** A default exchange for debouncing GraphQL requests. */


function dedupExchange(ref) {
  var forward = ref.forward;
  var dispatchDebug = ref.dispatchDebug;
  var inFlightKeys = new Set();

  function filterIncomingOperation(operation) {
    var key = operation.key;
    var kind = operation.kind;

    if (kind === 'teardown') {
      inFlightKeys.delete(key);
      return true;
    }

    if (kind !== 'query' && kind !== 'subscription') {
      return true;
    }

    var isInFlight = inFlightKeys.has(key);
    inFlightKeys.add(key);

    if (isInFlight) {
      process.env.NODE_ENV !== 'production' ? dispatchDebug({
        type: 'dedup',
        message: 'An operation has been deduped.',
        operation: operation,
        "source": "dedupExchange"
      }) : undefined;
    }

    return !isInFlight;
  }

  function afterOperationResult(ref) {
    var operation = ref.operation;
    var hasNext = ref.hasNext;

    if (!hasNext) {
      inFlightKeys.delete(operation.key);
    }
  }

  return function (ops$) {
    var forward$ = wonka.filter(filterIncomingOperation)(ops$);
    return wonka.tap(afterOperationResult)(forward(forward$));
  };
}
/* eslint-disable @typescript-eslint/no-use-before-define */

/** A default exchange for fetching GraphQL requests. */


function fetchExchange(ref) {
  var forward = ref.forward;
  var dispatchDebug = ref.dispatchDebug;
  return function (ops$) {
    var sharedOps$ = wonka.share(ops$);
    var fetchResults$ = wonka.mergeMap(function (operation) {
      var key = operation.key;
      var teardown$ = wonka.filter(function (op) {
        return op.kind === 'teardown' && op.key === key;
      })(sharedOps$);
      var body = fetchSource.makeFetchBody(operation);
      var url = fetchSource.makeFetchURL(operation, body);
      var fetchOptions = fetchSource.makeFetchOptions(operation, body);
      process.env.NODE_ENV !== 'production' ? dispatchDebug({
        type: 'fetchRequest',
        message: 'A fetch request is being executed.',
        operation: operation,
        data: {
          url: url,
          fetchOptions: fetchOptions
        },
        "source": "fetchExchange"
      }) : undefined;
      return wonka.onPush(function (result) {
        var error = !result.data ? result.error : undefined;
        process.env.NODE_ENV !== 'production' ? dispatchDebug({
          type: error ? 'fetchError' : 'fetchSuccess',
          message: "A " + (error ? 'failed' : 'successful') + " fetch response has been returned.",
          operation: operation,
          data: {
            url: url,
            fetchOptions: fetchOptions,
            value: error || result
          },
          "source": "fetchExchange"
        }) : undefined;
      })(wonka.takeUntil(teardown$)(fetchSource.makeFetchSource(operation, url, fetchOptions)));
    })(wonka.filter(function (operation) {
      return operation.kind === 'query' || operation.kind === 'mutation';
    })(sharedOps$));
    var forward$ = forward(wonka.filter(function (operation) {
      return operation.kind !== 'query' && operation.kind !== 'mutation';
    })(sharedOps$));
    return wonka.merge([fetchResults$, forward$]);
  };
}
/** This is always the last exchange in the chain; No operation should ever reach it */


function fallbackExchange(ref) {
  var dispatchDebug = ref.dispatchDebug;
  return function (ops$) {
    return (
      /* All operations that skipped through the entire exchange chain should be filtered from the output */
      wonka.filter(function () {
        return false;
      })(wonka.tap(function (operation) {
        if (operation.kind !== 'teardown' && process.env.NODE_ENV !== 'production') {
          var message = "No exchange has handled operations of kind \"" + operation.kind + "\". Check whether you've added an exchange responsible for these operations.";
          process.env.NODE_ENV !== 'production' ? dispatchDebug({
            type: 'fallbackCatch',
            message: message,
            operation: operation,
            "source": "fallbackExchange"
          }) : undefined;
          console.warn(message);
        }
      })(ops$))
    );
  };
}

var fallbackExchangeIO = fallbackExchange({
  dispatchDebug: noop
});
/** This composes an array of Exchanges into a single ExchangeIO function */

function composeExchanges(exchanges) {
  return function (ref) {
    var client = ref.client;
    var forward = ref.forward;
    var dispatchDebug = ref.dispatchDebug;
    return exchanges.reduceRight(function (forward, exchange) {
      return exchange({
        client: client,
        forward: forward,
        dispatchDebug: function dispatchDebug$1(event) {
          process.env.NODE_ENV !== 'production' ? dispatchDebug(fetchSource._extends({}, {
            timestamp: Date.now(),
            source: exchange.name
          }, event)) : undefined;
        }
      });
    }, forward);
  };
}

function errorExchange(ref) {
  var onError = ref.onError;
  return function (ref) {
    var forward = ref.forward;
    return function (ops$) {
      return wonka.tap(function (ref) {
        var error = ref.error;
        var operation = ref.operation;

        if (error) {
          onError(error, operation);
        }
      })(forward(ops$));
    };
  };
}

var defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];

var Client = function Client(opts) {
  if (process.env.NODE_ENV !== 'production' && !opts.url) {
    throw new Error('You are creating an urql-client without a url.');
  }

  var replays = new Map();
  var active = new Map();
  var queue = []; // This subject forms the input of operations; executeOperation may be
  // called to dispatch a new operation on the subject

  var ref = wonka.makeSubject();
  var operations$ = ref.source;
  var nextOperation = ref.next; // We define a queued dispatcher on the subject, which empties the queue when it's
  // activated to allow `reexecuteOperation` to be trampoline-scheduled

  var isOperationBatchActive = false;

  function dispatchOperation(operation) {
    if (operation) {
      nextOperation(operation);
    }

    if (!isOperationBatchActive) {
      isOperationBatchActive = true;

      while (isOperationBatchActive && (operation = queue.shift())) {
        nextOperation(operation);
      }

      isOperationBatchActive = false;
    }
  }
  /** Defines how result streams are created */


  function makeResultSource(operation) {
    var result$ = wonka.filter(function (res) {
      return res.operation.kind === operation.kind && res.operation.key === operation.key && (!res.operation.context._instance || res.operation.context._instance === operation.context._instance);
    })(results$); // Mask typename properties if the option for it is turned on

    if (client.maskTypename) {
      result$ = wonka.map(function (res) {
        return fetchSource._extends({}, res, {
          data: maskTypename(res.data)
        });
      })(result$);
    } // A mutation is always limited to just a single result and is never shared


    if (operation.kind === 'mutation') {
      return wonka.take(1)(wonka.onStart(function () {
        return nextOperation(operation);
      })(result$));
    }

    var source = wonka.share(wonka.onEnd(function () {
      // Delete the active operation handle
      replays.delete(operation.key);
      active.delete(operation.key); // Delete all queued up operations of the same key on end

      for (var i = queue.length - 1; i >= 0; i--) {
        if (queue[i].key === operation.key) {
          queue.splice(i, 1);
        }
      } // Dispatch a teardown signal for the stopped operation


      nextOperation(makeOperation('teardown', operation, operation.context));
    })(wonka.onPush(function (result) {
      replays.set(operation.key, result);
    })(wonka.switchMap(function (result) {
      if (operation.kind !== 'query' || result.stale) {
        return wonka.fromValue(result);
      }

      return wonka.merge([wonka.fromValue(result), // Mark a result as stale when a new operation is sent for it
      wonka.map(function () {
        return fetchSource._extends({}, result, {
          stale: true
        });
      })(wonka.take(1)(wonka.filter(function (op) {
        return op.kind === 'query' && op.key === operation.key && op.context.requestPolicy !== 'cache-only';
      })(operations$)))]);
    })( // End the results stream when an active teardown event is sent
    wonka.takeUntil(wonka.filter(function (op) {
      return op.kind === 'teardown' && op.key === operation.key;
    })(operations$))(result$)))));
    return source;
  }

  var instance = this instanceof Client ? this : Object.create(Client.prototype);

  var client = fetchSource._extends(instance, {
    url: opts.url,
    fetchOptions: opts.fetchOptions,
    fetch: opts.fetch,
    suspense: !!opts.suspense,
    requestPolicy: opts.requestPolicy || 'cache-first',
    preferGetMethod: !!opts.preferGetMethod,
    maskTypename: !!opts.maskTypename,
    operations$: operations$,
    reexecuteOperation: function reexecuteOperation(operation) {
      // Reexecute operation only if any subscribers are still subscribed to the
      // operation's exchange results
      if (operation.kind === 'mutation' || active.has(operation.key)) {
        queue.push(operation);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createOperationContext: function createOperationContext(opts) {
      if (!opts) {
        opts = {};
      }

      return fetchSource._extends({}, {
        _instance: undefined,
        url: client.url,
        fetchOptions: client.fetchOptions,
        fetch: client.fetch,
        preferGetMethod: client.preferGetMethod
      }, opts, {
        suspense: opts.suspense || opts.suspense !== false && client.suspense,
        requestPolicy: opts.requestPolicy || client.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(kind, request, opts) {
      var requestOperationType = fetchSource.getOperationType(request.query);

      if (process.env.NODE_ENV !== 'production' && kind !== 'teardown' && requestOperationType !== kind) {
        throw new Error("Expected operation of type \"" + kind + "\" but found \"" + requestOperationType + "\"");
      }

      var context = client.createOperationContext(opts);

      if (kind === 'mutation') {
        context._instance = [];
      }

      return makeOperation(kind, request, context);
    },
    executeRequestOperation: function executeRequestOperation(operation) {
      if (operation.kind === 'mutation') {
        return makeResultSource(operation);
      }

      return wonka.make(function (observer) {
        var source = active.get(operation.key);

        if (!source) {
          active.set(operation.key, source = makeResultSource(operation));
        }

        var isNetworkOperation = operation.context.requestPolicy === 'cache-and-network' || operation.context.requestPolicy === 'network-only';
        return wonka.subscribe(observer.next)(wonka.onEnd(function () {
          isOperationBatchActive = false;
          observer.complete();
        })(wonka.onStart(function () {
          var prevReplay = replays.get(operation.key);

          if (operation.kind === 'subscription') {
            return dispatchOperation(operation);
          } else if (isNetworkOperation) {
            dispatchOperation(operation);
          }

          if (prevReplay != null && prevReplay === replays.get(operation.key)) {
            observer.next(isNetworkOperation ? fetchSource._extends({}, prevReplay, {
              stale: true
            }) : prevReplay);
          } else if (!isNetworkOperation) {
            dispatchOperation(operation);
          }
        })(source))).unsubscribe;
      });
    },
    executeQuery: function executeQuery(query, opts) {
      var operation = client.createRequestOperation('query', query, opts);
      return client.executeRequestOperation(operation);
    },
    executeSubscription: function executeSubscription(query, opts) {
      var operation = client.createRequestOperation('subscription', query, opts);
      return client.executeRequestOperation(operation);
    },
    executeMutation: function executeMutation(query, opts) {
      var operation = client.createRequestOperation('mutation', query, opts);
      return client.executeRequestOperation(operation);
    },
    query: function query(query$1, variables, context) {
      if (!context || typeof context.suspense !== 'boolean') {
        context = fetchSource._extends({}, context, {
          suspense: false
        });
      }

      return withPromise(client.executeQuery(fetchSource.createRequest(query$1, variables), context));
    },
    readQuery: function readQuery(query, variables, context) {
      var result = null;
      wonka.subscribe(function (res) {
        result = res;
      })(client.query(query, variables, context)).unsubscribe();
      return result;
    },
    subscription: function subscription(query, variables, context) {
      return client.executeSubscription(fetchSource.createRequest(query, variables), context);
    },
    mutation: function mutation(query, variables, context) {
      return withPromise(client.executeMutation(fetchSource.createRequest(query, variables), context));
    }
  });

  var dispatchDebug = noop;

  if (process.env.NODE_ENV !== 'production') {
    var ref$1 = wonka.makeSubject();
    var next = ref$1.next;
    var source = ref$1.source;

    client.subscribeToDebugTarget = function (onEvent) {
      return wonka.subscribe(onEvent)(source);
    };

    dispatchDebug = next;
  }

  var exchanges = opts.exchanges !== undefined ? opts.exchanges : defaultExchanges; // All exchange are composed into a single one and are called using the constructed client
  // and the fallback exchange stream

  var composedExchange = composeExchanges(exchanges); // All exchanges receive inputs using which they can forward operations to the next exchange
  // and receive a stream of results in return, access the client, or dispatch debugging events
  // All operations then run through the Exchange IOs in a pipeline-like fashion

  var results$ = wonka.share(composedExchange({
    client: client,
    dispatchDebug: dispatchDebug,
    forward: fallbackExchange({
      dispatchDebug: dispatchDebug
    })
  })(operations$)); // Prevent the `results$` exchange pipeline from being closed by active
  // cancellations cascading up from components

  wonka.publish(results$);
  return client;
};

var createClient = Client;
exports.CombinedError = fetchSource.CombinedError;
exports.createRequest = fetchSource.createRequest;
exports.getOperationName = fetchSource.getOperationName;
exports.makeErrorResult = fetchSource.makeErrorResult;
exports.makeResult = fetchSource.makeResult;
exports.mergeResultPatch = fetchSource.mergeResultPatch;
exports.stringifyVariables = fetchSource.stringifyVariables;
exports.Client = Client;
exports.cacheExchange = cacheExchange;
exports.composeExchanges = composeExchanges;
exports.createClient = createClient;
exports.debugExchange = debugExchange;
exports.dedupExchange = dedupExchange;
exports.defaultExchanges = defaultExchanges;
exports.errorExchange = errorExchange;
exports.fallbackExchangeIO = fallbackExchangeIO;
exports.fetchExchange = fetchExchange;
exports.formatDocument = formatDocument;
exports.gql = gql;
exports.makeOperation = makeOperation;
exports.maskTypename = maskTypename;
exports.ssrExchange = ssrExchange;
exports.subscriptionExchange = subscriptionExchange;
//# sourceMappingURL=urql-core.js.map
