{"version":3,"file":"3ada59d5.js","sources":["../src/utils/error.ts","../src/utils/hash.ts","../src/utils/stringifyVariables.ts","../src/utils/request.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  Location,\n  DefinitionNode,\n  DocumentNode,\n  Kind,\n  parse,\n  print,\n} from 'graphql';\n\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest } from '../types';\n\ninterface WritableLocation {\n  loc: Location | undefined;\n}\n\nexport interface KeyedDocumentNode extends DocumentNode {\n  __key: number;\n}\n\nconst GRAPHQL_STRING_RE = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nconst REPLACE_CHAR_RE = /([\\s,]|#[^\\n\\r]+)+/g;\n\nconst replaceOutsideStrings = (str: string, idx: number) =>\n  idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, ' ').trim() : str;\n\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let str = (typeof node !== 'string'\n    ? (node.loc && node.loc.source.body) || print(node)\n    : node\n  )\n    .split(GRAPHQL_STRING_RE)\n    .map(replaceOutsideStrings)\n    .join('');\n\n  if (typeof node !== 'string') {\n    const operationName = 'definitions' in node && getOperationName(node);\n    if (operationName) {\n      str = `# ${operationName}\\n${str}`;\n    }\n\n    if (!node.loc) {\n      (node as WritableLocation).loc = {\n        start: 0,\n        end: str.length,\n        source: {\n          body: str,\n          name: 'gql',\n          locationOffset: { line: 1, column: 1 },\n        },\n      } as Location;\n    }\n  }\n\n  return str;\n};\n\nconst docs = new Map<number, KeyedDocumentNode>();\n\nexport const keyDocument = (q: string | DocumentNode): KeyedDocumentNode => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hash(stringifyDocument(q));\n    query = docs.get(key) || parse(q, { noLocation: true });\n  } else {\n    key = (q as KeyedDocumentNode).__key || hash(stringifyDocument(q));\n    query = docs.get(key) || q;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\nexport const createRequest = <Data = any, Variables = object>(\n  q: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  vars?: Variables\n): GraphQLRequest<Data, Variables> => {\n  if (!vars) vars = {} as Variables;\n  const query = keyDocument(q);\n  return {\n    key: phash(query.__key, stringifyVariables(vars)) >>> 0,\n    query,\n    variables: vars,\n  };\n};\n\n/**\n * Finds the Name value from the OperationDefinition of a Document\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\n/**\n * Finds the operation-type\n */\nexport const getOperationType = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n","import { ExecutionResult, Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: ExecutionResult,\n  response?: any\n): OperationResult => {\n  if ((!('data' in result) && !('errors' in result)) || 'path' in result) {\n    throw new Error('No Content');\n  }\n\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors)\n      ? new CombinedError({\n          graphQLErrors: result.errors,\n          response,\n        })\n      : undefined,\n    extensions:\n      (typeof result.extensions === 'object' && result.extensions) || undefined,\n    hasNext: !!result.hasNext,\n  };\n};\n\nexport const mergeResultPatch = (\n  prevResult: OperationResult,\n  patch: ExecutionResult,\n  response?: any\n): OperationResult => {\n  const result = { ...prevResult };\n  result.hasNext = !!patch.hasNext;\n\n  if (!('path' in patch)) {\n    if ('data' in patch) result.data = patch.data;\n    return result;\n  }\n\n  if (Array.isArray(patch.errors)) {\n    result.error = new CombinedError({\n      graphQLErrors: result.error\n        ? [...result.error.graphQLErrors, ...patch.errors]\n        : patch.errors,\n      response,\n    });\n  }\n\n  let part: Record<string, any> | Array<any> = (result.data = {\n    ...result.data,\n  });\n\n  let i = 0;\n  let prop: string | number;\n  while (i < patch.path.length) {\n    prop = patch.path[i++];\n    part = part[prop] = Array.isArray(part[prop])\n      ? [...part[prop]]\n      : { ...part[prop] };\n  }\n\n  Object.assign(part, patch.data);\n  return result;\n};\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { DocumentNode, print } from 'graphql';\n\nimport { getOperationName, stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return operation.kind === 'query' && !!operation.context.preferGetMethod;\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  const url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  const search: string[] = [];\n  if (body.operationName) {\n    search.push('operationName=' + encodeURIComponent(body.operationName));\n  }\n\n  if (body.query) {\n    search.push(\n      'query=' +\n        encodeURIComponent(body.query.replace(/#[^\\n\\r]+/g, ' ').trim())\n    );\n  }\n\n  if (body.variables) {\n    search.push(\n      'variables=' + encodeURIComponent(stringifyVariables(body.variables))\n    );\n  }\n\n  if (body.extensions) {\n    search.push(\n      'extensions=' + encodeURIComponent(stringifyVariables(body.extensions))\n    );\n  }\n\n  const finalUrl = `${url}?${search.join('&')}`;\n\n  if (finalUrl.length > 2047) {\n    operation.context.preferGetMethod = false;\n    return url;\n  }\n\n  return finalUrl;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n  const headers: HeadersInit = {\n    accept: 'application/graphql+json, application/json',\n  };\n  if (!useGETMethod) headers['content-type'] = 'application/json';\n  const extraOptions =\n    (typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions) || {};\n  if (extraOptions.headers)\n    for (const key in extraOptions.headers)\n      headers[key.toLowerCase()] = extraOptions.headers[key];\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers,\n  };\n};\n","import { Source, make } from 'wonka';\nimport { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult, mergeResultPatch } from '../utils';\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nconst jsonHeaderRe = /content-type:[^\\r\\n]*application\\/json/i;\nconst boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\n\ntype ChunkData = { done: false; value: Buffer | Uint8Array } | { done: true };\n\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nconst toString = (input: Buffer | ArrayBuffer): string =>\n  input.constructor.name === 'Buffer'\n    ? (input as Buffer).toString()\n    : decoder!.decode(input as ArrayBuffer);\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Source<OperationResult> => {\n  const maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;\n  const fetcher = operation.context.fetch;\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n    if (abortController) {\n      fetchOptions.signal = abortController.signal;\n    }\n\n    let hasResults = false;\n    // DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>\n    // See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts\n    const executeIncrementalFetch = (\n      onResult: (result: OperationResult) => void,\n      operation: Operation,\n      response: Response\n    ): Promise<void> => {\n      // NOTE: Guarding against fetch polyfills here\n      const contentType =\n        (response.headers && response.headers.get('Content-Type')) || '';\n      if (/text\\//i.test(contentType)) {\n        return response.text().then(text => {\n          onResult(makeErrorResult(operation, new Error(text), response));\n        });\n      } else if (!/multipart\\/mixed/i.test(contentType)) {\n        return response.text().then(payload => {\n          onResult(makeResult(operation, JSON.parse(payload), response));\n        });\n      }\n\n      let boundary = '---';\n      const boundaryHeader = contentType.match(boundaryHeaderRe);\n      if (boundaryHeader) boundary = '--' + boundaryHeader[1];\n\n      let read: () => Promise<ChunkData>;\n      let cancel = () => {\n        /*noop*/\n      };\n      if (asyncIterator && response[asyncIterator]) {\n        const iterator = response[asyncIterator]();\n        read = iterator.next.bind(iterator);\n      } else if ('body' in response && response.body) {\n        const reader = response.body.getReader();\n        cancel = reader.cancel.bind(reader);\n        read = reader.read.bind(reader);\n      } else {\n        throw new TypeError('Streaming requests unsupported');\n      }\n\n      let buffer = '';\n      let isPreamble = true;\n      let nextResult: OperationResult | null = null;\n      let prevResult: OperationResult | null = null;\n\n      function next(data: ChunkData): Promise<void> | void {\n        if (!data.done) {\n          const chunk = toString(data.value);\n          let boundaryIndex = chunk.indexOf(boundary);\n          if (boundaryIndex > -1) {\n            boundaryIndex += buffer.length;\n          } else {\n            boundaryIndex = buffer.indexOf(boundary);\n          }\n\n          buffer += chunk;\n          while (boundaryIndex > -1) {\n            const current = buffer.slice(0, boundaryIndex);\n            const next = buffer.slice(boundaryIndex + boundary.length);\n\n            if (isPreamble) {\n              isPreamble = false;\n            } else {\n              const headersEnd = current.indexOf('\\r\\n\\r\\n') + 4;\n              const headers = current.slice(0, headersEnd);\n              const body = current.slice(\n                headersEnd,\n                current.lastIndexOf('\\r\\n')\n              );\n\n              let payload: any;\n              if (jsonHeaderRe.test(headers)) {\n                try {\n                  payload = JSON.parse(body);\n                  nextResult = prevResult = prevResult\n                    ? mergeResultPatch(prevResult, payload, response)\n                    : makeResult(operation, payload, response);\n                } catch (_error) {}\n              }\n\n              if (next.slice(0, 2) === '--' || (payload && !payload.hasNext)) {\n                if (!prevResult)\n                  return onResult(makeResult(operation, {}, response));\n                break;\n              }\n            }\n\n            buffer = next;\n            boundaryIndex = buffer.indexOf(boundary);\n          }\n        } else {\n          hasResults = true;\n        }\n\n        if (nextResult) {\n          onResult(nextResult);\n          nextResult = null;\n        }\n\n        if (!data.done && (!prevResult || prevResult.hasNext)) {\n          return read().then(next);\n        }\n      }\n\n      return read().then(next).finally(cancel);\n    };\n\n    let ended = false;\n    let statusNotOk = false;\n    let response: Response;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) return;\n        return (fetcher || fetch)(url, fetchOptions);\n      })\n      .then((_response: Response | void) => {\n        if (!_response) return;\n        response = _response;\n        statusNotOk = response.status < 200 || response.status >= maxStatus;\n        return executeIncrementalFetch(next, operation, response);\n      })\n      .then(complete)\n      .catch((error: Error) => {\n        if (hasResults) {\n          throw error;\n        }\n\n        const result = makeErrorResult(\n          operation,\n          statusNotOk\n            ? response.statusText\n              ? new Error(response.statusText)\n              : error\n            : error,\n          response\n        );\n\n        next(result);\n        complete();\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["generateErrorMessage","networkErr","graphQlErrs","forEach","err","error","message","trim","rehydrateGraphQlError","GraphQLError","nodes","source","positions","path","extensions","CombinedError","Error","ref","networkError","graphQLErrors","const","normalizedGraphQLErrors","map","name","response","phash","h","x","let","i","l","length","charCodeAt","hash","seen","Set","cache","WeakMap","stringify","toJSON","Array","isArray","out","value","keys","constructor","Object","set","key","add","delete","stringifyVariables","GRAPHQL_STRING_RE","REPLACE_CHAR_RE","replaceOutsideStrings","str","idx","replace","stringifyDocument","node","loc","body","print","operationName","start","docs","Map","keyDocument","q","query","get","parse","noLocation","__key","createRequest","vars","variables","getOperationName","definitions","getOperationType","kind","Kind","OPERATION_DEFINITION","makeResult","operation","result","undefined","hasNext","mergeResultPatch","prevResult","patch","data","concat","errors","part","prop","makeErrorResult","shouldUseGet","context","preferGetMethod","makeFetchBody","request","makeFetchURL","useGETMethod","url","search","push","encodeURIComponent","finalUrl","join","makeFetchOptions","headers","accept","fetchOptions","extraOptions","toLowerCase","JSON","asyncIterator","Symbol","decoder","TextDecoder","jsonHeaderRe","boundaryHeaderRe","toString","input","decode","makeFetchSource","maxStatus","redirect","fetcher","fetch","abortController","AbortController","signal","contentType","test","onResult","text","payload","boundaryHeader","boundary","read","iterator","TypeError","done","boundaryIndex","buffer","indexOf","next","slice","isPreamble","current","headersEnd","lastIndexOf","nextResult","then","finally","cancel","ended","_response","statusNotOk","status","catch","hasResults","statusText","complete"],"mappings":"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"}