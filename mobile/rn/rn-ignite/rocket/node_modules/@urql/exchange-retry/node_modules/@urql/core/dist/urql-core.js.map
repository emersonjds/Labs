{"version":3,"file":"urql-core.js","sources":["../src/utils/typenames.ts","../src/utils/maskTypename.ts","../src/utils/streamUtils.ts","../src/utils/operation.ts","../src/utils/index.ts","../src/gql.ts","../src/exchanges/cache.ts","../src/exchanges/ssr.ts","../src/exchanges/subscription.ts","../src/exchanges/debug.ts","../src/exchanges/dedup.ts","../src/exchanges/fetch.ts","../src/exchanges/fallback.ts","../src/exchanges/compose.ts","../src/exchanges/error.ts","../src/exchanges/index.ts","../src/client.ts"],"sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  visit,\n} from 'graphql';\n\nimport { KeyedDocumentNode, keyDocument } from './request';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (\n  obj: EntityLike | EntityLike[],\n  types: { [typename: string]: unknown }\n) => {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) collectTypes(obj[i], types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types[obj[key] as string] = 0;\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  Object.keys(collectTypes(response as EntityLike, {}));\n\nconst formatNode = (node: FieldNode | InlineFragmentNode) => {\n  if (\n    node.selectionSet &&\n    !node.selectionSet.selections.some(\n      node =>\n        node.kind === Kind.FIELD &&\n        node.name.value === '__typename' &&\n        !node.alias\n    )\n  ) {\n    return {\n      ...node,\n      selectionSet: {\n        ...node.selectionSet,\n        selections: [\n          ...(node.selectionSet.selections as SelectionNode[]),\n          {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          },\n        ],\n      },\n    };\n  }\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\nexport const formatDocument = <T extends DocumentNode>(node: T): T => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    result = visit(query, {\n      Field: formatNode,\n      InlineFragment: formatNode,\n    }) as KeyedDocumentNode;\n\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false,\n    });\n\n    formattedDocs.set(query.__key, result);\n  }\n\n  return (result as unknown) as T;\n};\n","export const maskTypename = (data: any): any => {\n  if (!data || typeof data !== 'object') return data;\n\n  return Object.keys(data).reduce(\n    (acc, key: string) => {\n      const value = data[key];\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value,\n        });\n      } else if (Array.isArray(value)) {\n        acc[key] = value.map(maskTypename);\n      } else if (value && typeof value === 'object' && '__typename' in value) {\n        acc[key] = maskTypename(value);\n      } else {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    Array.isArray(data) ? [] : {}\n  );\n};\n","import { Source, subscribe, pipe } from 'wonka';\nimport { OperationResult, PromisifiedSource } from '../types';\n\nexport function withPromise<T extends OperationResult>(\n  source$: Source<T>\n): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () => {\n    return new Promise(resolve => {\n      const subscription = pipe(\n        source$,\n        subscribe(result => {\n          if (!result.stale && !result.hasNext) {\n            Promise.resolve().then(() => {\n              subscription.unsubscribe();\n              resolve(result);\n            });\n          }\n        })\n      );\n    });\n  };\n\n  return source$ as PromisifiedSource<T>;\n}\n","import {\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  if (!context) context = request.context;\n\n  return {\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    kind,\n    context,\n  };\n}\n\nexport { makeOperation };\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","export * from './error';\nexport * from './request';\nexport * from './result';\nexport * from './typenames';\nexport * from './stringifyVariables';\nexport * from './maskTypename';\nexport * from './streamUtils';\nexport * from './operation';\n\nexport const noop = () => {\n  /* noop */\n};\n","/* eslint-disable prefer-rest-params */\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  FragmentDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { keyDocument, stringifyDocument } from './utils';\n\nconst applyDefinitions = (\n  fragmentNames: Map<string, string>,\n  target: DefinitionNode[],\n  source: Array<DefinitionNode> | ReadonlyArray<DefinitionNode>\n) => {\n  for (let i = 0; i < source.length; i++) {\n    if (source[i].kind === Kind.FRAGMENT_DEFINITION) {\n      const name = (source[i] as FragmentDefinitionNode).name.value;\n      const value = stringifyDocument(source[i]);\n      // Fragments will be deduplicated according to this Map\n      if (!fragmentNames.has(name)) {\n        fragmentNames.set(name, value);\n        target.push(source[i]);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        fragmentNames.get(name) !== value\n      ) {\n        // Fragments with the same names is expected to have the same contents\n        console.warn(\n          '[WARNING: Duplicate Fragment] A fragment with name `' +\n            name +\n            '` already exists in this document.\\n' +\n            'While fragment names may not be unique across your source, each name must be unique per document.'\n        );\n      }\n    } else {\n      target.push(source[i]);\n    }\n  }\n};\n\nfunction gql<Data = any, Variables = object>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables = object>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(/* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const interpolations: DefinitionNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(arguments[0])\n    ? arguments[0][0]\n    : arguments[0] || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      interpolations.push(...value.definitions);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  // Apply the tag's body definitions\n  applyDefinitions(fragmentNames, definitions, keyDocument(body).definitions);\n  // Copy over each interpolated document's definitions\n  applyDefinitions(fragmentNames, definitions, interpolations);\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = formatDocument(operation.query);\n    return formattedOperation;\n  };\n\n  const isOperationCached = (operation: Operation) => {\n    const {\n      key,\n      kind,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      kind === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        const typenames = collectTypesFromResponse(response.data).concat(\n          operation.context.additionalTypenames || []\n        );\n\n        // Invalidates the cache given a mutation's response\n        if (response.operation.kind === 'mutation') {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.forEach(key => {\n              pendingOperations.add(key);\n            });\n            operations.clear();\n          }\n\n          pendingOperations.forEach(key => {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          });\n          // Mark typenames on typenameInvalidate for early invalidation\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nexport const reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import { GraphQLError } from 'graphql';\nimport { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\nimport { reexecuteOperation } from './cache';\n\nexport interface SerializedResult {\n  hasNext?: boolean;\n  data?: string | undefined; // JSON string of data\n  extensions?: string | undefined; // JSON string of data\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n  staleWhileRevalidate?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = (\n  { hasNext, data, extensions, error }: OperationResult,\n  includeExtensions: boolean\n): SerializedResult => {\n  const result: SerializedResult = {};\n  if (data !== undefined) result.data = JSON.stringify(data);\n  if (includeExtensions && extensions !== undefined) {\n    result.extensions = JSON.stringify(extensions);\n  }\n  if (hasNext) result.hasNext = true;\n\n  if (error) {\n    result.error = {\n      graphQLErrors: error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (error.networkError) {\n      result.error.networkError = '' + error.networkError;\n    }\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult,\n  includeExtensions: boolean\n): OperationResult => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions:\n    includeExtensions && result.extensions\n      ? JSON.parse(result.extensions)\n      : undefined,\n  error: result.error\n    ? new CombinedError({\n        networkError: result.error.networkError\n          ? new Error(result.error.networkError)\n          : undefined,\n        graphQLErrors: result.error.graphQLErrors,\n      })\n    : undefined,\n  hasNext: result.hasNext,\n});\n\nconst revalidated = new Set<number>();\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const staleWhileRevalidate = !!(params && params.staleWhileRevalidate);\n  const includeExtensions = !!(params && params.includeExtensions);\n  const data: Record<string, SerializedResult | null> = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(\n        operation => !data[operation.key] || !!data[operation.key]!.hasNext\n      ),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(\n        operation =>\n          !!data[operation.key] &&\n          operation.context.requestPolicy !== 'network-only'\n      ),\n      map(op => {\n        const serialized = data[op.key]!;\n        const result = deserializeResult(op, serialized, includeExtensions);\n        if (staleWhileRevalidate && !revalidated.has(op.key)) {\n          result.stale = true;\n          revalidated.add(op.key);\n          reexecuteOperation(client, op);\n        }\n\n        return result;\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (operation.kind !== 'mutation') {\n            const serialized = serializeResult(result, includeExtensions);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(cachedOps$, tap(invalidate));\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => {\n    for (const key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[key] !== null) {\n        data[key] = restore[key];\n      }\n    }\n  };\n\n  ssr.extractData = () => {\n    const result: SSRData = {};\n    for (const key in data) if (data[key] != null) result[key] = data[key]!;\n    return result;\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult, makeOperation } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: Record<string, unknown>;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n\n  /** This flag may be turned on to allow your subscriptions-transport to handle all operation types */\n  enableAllOperations?: boolean;\n  isSubscriptionOperation?: (operation: Operation) => boolean;\n}\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n  isSubscriptionOperation,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n      let sub;\n\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n\n        sub = observableish.subscribe({\n          next: result => next(makeResult(operation, result)),\n          error: err => next(makeErrorResult(operation, err)),\n          complete: () => {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.kind === 'subscription') {\n                client.reexecuteOperation(\n                  makeOperation('teardown', operation, operation.context)\n                );\n              }\n\n              complete();\n            }\n          },\n        });\n      });\n\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n  const isSubscriptionOperationFn =\n    isSubscriptionOperation ||\n    (operation => {\n      const { kind } = operation;\n      return (\n        kind === 'subscription' ||\n        (!!enableAllOperations && (kind === 'query' || kind === 'mutation'))\n      );\n    });\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperationFn),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperationFn(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward, dispatchDebug }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, kind } = operation;\n    if (kind === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    }\n\n    if (kind !== 'query' && kind !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n\n    if (isInFlight) {\n      dispatchDebug({\n        type: 'dedup',\n        message: 'An operation has been deduped.',\n        operation,\n      });\n    }\n\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation, hasNext }: OperationResult) => {\n    if (!hasNext) {\n      inFlightKeys.delete(operation.key);\n    }\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, share, takeUntil, onPush } from 'wonka';\n\nimport { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind === 'query' || operation.kind === 'mutation';\n      }),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        return pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(teardown$),\n          onPush(result => {\n            const error = !result.data ? result.error : undefined;\n\n            dispatchDebug({\n              type: error ? 'fetchError' : 'fetchSuccess',\n              message: `A ${\n                error ? 'failed' : 'successful'\n              } fetch response has been returned.`,\n              operation,\n              data: {\n                url,\n                fetchOptions,\n                value: error || result,\n              },\n            });\n          })\n        );\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind !== 'query' && operation.kind !== 'mutation';\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Operation, ExchangeIO, ExchangeInput } from '../types';\nimport { noop } from '../utils';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO = ({\n  dispatchDebug,\n}) => ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(operation => {\n      if (\n        operation.kind !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n        dispatchDebug({\n          type: 'fallbackCatch',\n          message,\n          operation,\n        });\n        console.warn(message);\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n\nexport const fallbackExchangeIO: ExchangeIO = fallbackExchange({\n  dispatchDebug: noop,\n});\n","import { Exchange, ExchangeInput } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]) => ({\n  client,\n  forward,\n  dispatchDebug,\n}: ExchangeInput) =>\n  exchanges.reduceRight(\n    (forward, exchange) =>\n      exchange({\n        client,\n        forward,\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      }),\n    forward\n  );\n","import { pipe, tap } from 'wonka';\nimport { Exchange, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport const errorExchange = ({\n  onError,\n}: {\n  onError: (error: CombinedError, operation: Operation) => void;\n}): Exchange => ({ forward }) => ops$ => {\n  return pipe(\n    forward(ops$),\n    tap(({ error, operation }) => {\n      if (error) {\n        onError(error, operation);\n      }\n    })\n  );\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\nexport { errorExchange } from './error';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport {\n  filter,\n  make,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n  Subscription,\n} from 'wonka';\n\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { DocumentNode } from 'graphql';\n\nimport { composeExchanges, defaultExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport {\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n  getOperationType,\n} from './utils';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n  /** Use HTTP GET for queries. */\n  preferGetMethod?: boolean;\n  /** Mask __typename from results. */\n  maskTypename?: boolean;\n}\n\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  operations$: Source<Operation>;\n\n  /** Start an operation from an exchange */\n  reexecuteOperation: (operation: Operation) => void;\n  /** Event target for monitoring, e.g. for @urql/devtools */\n  subscribeToDebugTarget?: (onEvent: (e: DebugEvent) => void) => Subscription;\n\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n  preferGetMethod: boolean;\n  maskTypename: boolean;\n\n  createOperationContext(\n    opts?: Partial<OperationContext> | undefined\n  ): OperationContext;\n\n  createRequestOperation<Data = any, Variables = object>(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation<Data = any, Variables = object>(\n    operation: Operation<Data, Variables>\n  ): Source<OperationResult<Data, Variables>>;\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  readQuery<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  executeQuery<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  subscription<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>>;\n\n  executeSubscription<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  executeMutation<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const queue: Operation[] = [];\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const { source: operations$, next: nextOperation } = makeSubject<Operation>();\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    if (operation) nextOperation(operation);\n    if (!isOperationBatchActive) {\n      isOperationBatchActive = true;\n      while (isOperationBatchActive && (operation = queue.shift()))\n        nextOperation(operation);\n      isOperationBatchActive = false;\n    }\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      filter((res: OperationResult) => {\n        return (\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key &&\n          (!res.operation.context._instance ||\n            res.operation.context._instance === operation.context._instance)\n        );\n      })\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (client.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data) }))\n      );\n    }\n\n    // A mutation is always limited to just a single result and is never shared\n    if (operation.kind === 'mutation') {\n      return pipe(\n        result$,\n        onStart(() => nextOperation(operation)),\n        take(1)\n      );\n    }\n\n    const source = pipe(\n      result$,\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations$,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      ),\n      switchMap(result => {\n        if (operation.kind !== 'query' || result.stale) {\n          return fromValue(result);\n        }\n\n        return merge([\n          fromValue(result),\n          // Mark a result as stale when a new operation is sent for it\n          pipe(\n            operations$,\n            filter(\n              op =>\n                op.kind === 'query' &&\n                op.key === operation.key &&\n                op.context.requestPolicy !== 'cache-only'\n            ),\n            take(1),\n            map(() => ({ ...result, stale: true }))\n          ),\n        ]);\n      }),\n      onPush(result => {\n        replays.set(operation.key, result);\n      }),\n      onEnd(() => {\n        // Delete the active operation handle\n        replays.delete(operation.key);\n        active.delete(operation.key);\n        // Delete all queued up operations of the same key on end\n        for (let i = queue.length - 1; i >= 0; i--)\n          if (queue[i].key === operation.key) queue.splice(i, 1);\n        // Dispatch a teardown signal for the stopped operation\n        nextOperation(makeOperation('teardown', operation, operation.context));\n      }),\n      share\n    );\n\n    return source;\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    url: opts.url,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    suspense: !!opts.suspense,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n    preferGetMethod: !!opts.preferGetMethod,\n    maskTypename: !!opts.maskTypename,\n\n    operations$,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'mutation' || active.has(operation.key)) {\n        queue.push(operation);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n\n    createOperationContext(opts) {\n      if (!opts) opts = {};\n\n      return {\n        _instance: undefined,\n        url: client.url,\n        fetchOptions: client.fetchOptions,\n        fetch: client.fetch,\n        preferGetMethod: client.preferGetMethod,\n        ...opts,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n        requestPolicy: opts.requestPolicy || client.requestPolicy,\n      };\n    },\n\n    createRequestOperation(kind, request, opts) {\n      const requestOperationType = getOperationType(request.query);\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        kind !== 'teardown' &&\n        requestOperationType !== kind\n      ) {\n        throw new Error(\n          `Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`\n        );\n      }\n      const context = client.createOperationContext(opts);\n      if (kind === 'mutation') (context as any)._instance = [];\n      return makeOperation(kind, request, context);\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return makeResultSource(operation);\n      }\n\n      return make(observer => {\n        let source = active.get(operation.key);\n\n        if (!source) {\n          active.set(operation.key, (source = makeResultSource(operation)));\n        }\n\n        const isNetworkOperation =\n          operation.context.requestPolicy === 'cache-and-network' ||\n          operation.context.requestPolicy === 'network-only';\n\n        return pipe(\n          source,\n          onStart(() => {\n            const prevReplay = replays.get(operation.key);\n\n            if (operation.kind === 'subscription') {\n              return dispatchOperation(operation);\n            } else if (isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n\n            if (\n              prevReplay != null &&\n              prevReplay === replays.get(operation.key)\n            ) {\n              observer.next(\n                isNetworkOperation ? { ...prevReplay, stale: true } : prevReplay\n              );\n            } else if (!isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n          }),\n          onEnd(() => {\n            isOperationBatchActive = false;\n            observer.complete();\n          }),\n          subscribe(observer.next)\n        ).unsubscribe;\n      });\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    query(query, variables, context) {\n      if (!context || typeof context.suspense !== 'boolean') {\n        context = { ...context, suspense: false };\n      }\n\n      return withPromise(\n        client.executeQuery(createRequest(query, variables), context)\n      );\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return withPromise(\n        client.executeMutation(createRequest(query, variables), context)\n      );\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  const exchanges =\n    opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations$)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\nexport const createClient = (Client as any) as (opts: ClientOptions) => Client;\n"],"names":["collectTypes","obj","types","Array","isArray","let","i","length","const","key","collectTypesFromResponse","response","Object","keys","formatNode","node","selectionSet","selections","some","kind","Kind","FIELD","name","value","alias","_extends","concat","formattedDocs","Map","formatDocument","query","keyDocument","result","visit","Field","InlineFragment","defineProperty","enumerable","maskTypename","data","reduce","acc","withPromise","source$","toPromise","Promise","resolve","then","makeOperation","request","context","addMetadata","operation","meta","noop","applyDefinitions","fragmentNames","target","source","has","set","process","env","NODE_ENV","get","gql","arguments","definitions","body","interpolations","shouldSkip","ref","cacheExchange","forward","client","resultCache","mapTypeNames","formattedOperation","isOperationCached","requestPolicy","sharedOps$","share","ops$","cachedOps$","map","dispatchDebug","cachedResult","type","message","stale","reexecuteOperation","filter","op","forwardedOps$","typenames","additionalTypenames","pendingOperations","Set","typeName","operations","operationCache","forEach","add","delete","merge","serializeResult","includeExtensions","hasNext","extensions","undefined","error","deserializeResult","JSON","parse","networkError","graphQLErrors","revalidated","ssrExchange","params","invalidate","invalidateQueue","ssr","isClient","suspense","serialized","restoreData","restore","extractData","initialState","subscriptionExchange","forwardSubscription","enableAllOperations","createSubscriptionSource","print","sub","isComplete","observableish","subscribe","next","makeResult","err","makeErrorResult","complete","subscriptionResults$","mergeMap","takeUntil","teardown$","isSubscriptionOperationFn","debugExchange","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","tap","afterOperationResult","forward$","fetchExchange","makeFetchBody","fallbackExchange","console","warn","fallbackExchangeIO","composeExchanges","exchanges","reduceRight","exchange","dispatchDebug$1","event","timestamp","Date","now","errorExchange","onError","defaultExchanges","Client","opts","url","Error","replays","active","makeSubject","operations$","nextOperation","makeResultSource","res","_instance","result$","onEnd","queue","splice","onPush","switchMap","fromValue","take","instance","preferGetMethod","push","createOperationContext","createRequestOperation","executeRequestOperation","make","observer","onStart","dispatchOperation","isNetworkOperation","variables","executeQuery","createRequest","readQuery","unsubscribe","subscription","executeSubscription","mutation","executeMutation","subscribeToDebugTarget","onEvent","composedExchange","results$","publish","createClient"],"mappings":"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"}