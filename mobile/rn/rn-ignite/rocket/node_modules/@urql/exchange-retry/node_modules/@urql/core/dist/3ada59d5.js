var graphql = require('graphql');

var wonka = require('wonka');

function generateErrorMessage(networkErr, graphQlErrs) {
  var error = '';

  if (networkErr !== undefined) {
    return error = "[Network] " + networkErr.message;
  }

  if (graphQlErrs !== undefined) {
    graphQlErrs.forEach(function (err) {
      error += "[GraphQL] " + err.message + "\n";
    });
  }

  return error.trim();
}

function rehydrateGraphQlError(error) {
  if (typeof error === 'string') {
    return new graphql.GraphQLError(error);
  } else if (typeof error === 'object' && error.message) {
    return new graphql.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});
  } else {
    return error;
  }
}
/** An error which can consist of GraphQL errors and Network errors. */


var CombinedError = /*@__PURE__*/function (Error) {
  function CombinedError(ref) {
    var networkError = ref.networkError;
    var graphQLErrors = ref.graphQLErrors;
    var response = ref.response;
    var normalizedGraphQLErrors = (graphQLErrors || []).map(rehydrateGraphQlError);
    var message = generateErrorMessage(networkError, normalizedGraphQLErrors);
    Error.call(this, message);
    this.name = 'CombinedError';
    this.message = message;
    this.graphQLErrors = normalizedGraphQLErrors;
    this.networkError = networkError;
    this.response = response;
  }

  if (Error) CombinedError.__proto__ = Error;
  CombinedError.prototype = Object.create(Error && Error.prototype);
  CombinedError.prototype.constructor = CombinedError;

  CombinedError.prototype.toString = function toString() {
    return this.message;
  };

  return CombinedError;
}(Error); // When we have separate strings it's useful to run a progressive
// version of djb2 where we pretend that we're still looping over
// the same string


function phash(h, x) {
  h = h | 0;

  for (var i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }

  return h;
}

function hash(x) {
  return phash(5381 | 0, x) >>> 0;
}

var seen = new Set();
var cache = new WeakMap();

function stringify(x) {
  if (x === null || seen.has(x)) {
    return 'null';
  } else if (typeof x !== 'object') {
    return JSON.stringify(x) || '';
  } else if (x.toJSON) {
    return stringify(x.toJSON());
  } else if (Array.isArray(x)) {
    var out$1 = '[';

    for (var i = 0, l = x.length; i < l; i++) {
      if (i > 0) {
        out$1 += ',';
      }

      var value = stringify(x[i]);
      out$1 += value.length > 0 ? value : 'null';
    }

    out$1 += ']';
    return out$1;
  }

  var keys = Object.keys(x).sort();

  if (!keys.length && x.constructor && x.constructor !== Object) {
    var key = cache.get(x) || Math.random().toString(36).slice(2);
    cache.set(x, key);
    return "{\"__key\":\"" + key + "\"}";
  }

  seen.add(x);
  var out = '{';

  for (var i$1 = 0, l$1 = keys.length; i$1 < l$1; i$1++) {
    var key$1 = keys[i$1];
    var value$1 = stringify(x[key$1]);

    if (value$1) {
      if (out.length > 1) {
        out += ',';
      }

      out += stringify(key$1) + ':' + value$1;
    }
  }

  seen.delete(x);
  out += '}';
  return out;
}

function stringifyVariables(x) {
  seen.clear();
  return stringify(x);
}

var GRAPHQL_STRING_RE = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var REPLACE_CHAR_RE = /([\s,]|#[^\n\r]+)+/g;

function replaceOutsideStrings(str, idx) {
  return idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, ' ').trim() : str;
}

function stringifyDocument(node) {
  var str = (typeof node !== 'string' ? node.loc && node.loc.source.body || graphql.print(node) : node).split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('');

  if (typeof node !== 'string') {
    var operationName = 'definitions' in node && getOperationName(node);

    if (operationName) {
      str = "# " + operationName + "\n" + str;
    }

    if (!node.loc) {
      node.loc = {
        start: 0,
        end: str.length,
        source: {
          body: str,
          name: 'gql',
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      };
    }
  }

  return str;
}

var docs = new Map();

function keyDocument(q) {
  var key;
  var query;

  if (typeof q === 'string') {
    key = hash(stringifyDocument(q));
    query = docs.get(key) || graphql.parse(q, {
      noLocation: true
    });
  } else {
    key = q.__key || hash(stringifyDocument(q));
    query = docs.get(key) || q;
  } // Add location information if it's missing


  if (!query.loc) {
    stringifyDocument(query);
  }

  query.__key = key;
  docs.set(key, query);
  return query;
}

function createRequest(q, vars) {
  if (!vars) {
    vars = {};
  }

  var query = keyDocument(q);
  return {
    key: phash(query.__key, stringifyVariables(vars)) >>> 0,
    query: query,
    variables: vars
  };
}

function getOperationName(query) {
  for (var i = 0, l = query.definitions.length; i < l; i++) {
    var node = query.definitions[i];

    if (node.kind === graphql.Kind.OPERATION_DEFINITION && node.name) {
      return node.name.value;
    }
  }
}

function getOperationType(query) {
  for (var i = 0, l = query.definitions.length; i < l; i++) {
    var node = query.definitions[i];

    if (node.kind === graphql.Kind.OPERATION_DEFINITION) {
      return node.operation;
    }
  }
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function makeResult(operation, result, response) {
  if (!('data' in result) && !('errors' in result) || 'path' in result) {
    throw new Error('No Content');
  }

  return {
    operation: operation,
    data: result.data,
    error: Array.isArray(result.errors) ? new CombinedError({
      graphQLErrors: result.errors,
      response: response
    }) : undefined,
    extensions: typeof result.extensions === 'object' && result.extensions || undefined,
    hasNext: !!result.hasNext
  };
}

function mergeResultPatch(prevResult, patch, response) {
  var result = _extends({}, prevResult);

  result.hasNext = !!patch.hasNext;

  if (!('path' in patch)) {
    if ('data' in patch) {
      result.data = patch.data;
    }

    return result;
  }

  if (Array.isArray(patch.errors)) {
    result.error = new CombinedError({
      graphQLErrors: result.error ? result.error.graphQLErrors.concat(patch.errors) : patch.errors,
      response: response
    });
  }

  var part = result.data = _extends({}, result.data);

  var i = 0;
  var prop;

  while (i < patch.path.length) {
    prop = patch.path[i++];
    part = part[prop] = Array.isArray(part[prop]) ? [].concat(part[prop]) : _extends({}, part[prop]);
  }

  _extends(part, patch.data);

  return result;
}

function makeErrorResult(operation, error, response) {
  return {
    operation: operation,
    data: undefined,
    error: new CombinedError({
      networkError: error,
      response: response
    }),
    extensions: undefined
  };
}

function shouldUseGet(operation) {
  return operation.kind === 'query' && !!operation.context.preferGetMethod;
}

function makeFetchBody(request) {
  return {
    query: graphql.print(request.query),
    operationName: getOperationName(request.query),
    variables: request.variables || undefined,
    extensions: undefined
  };
}

function makeFetchURL(operation, body) {
  var useGETMethod = shouldUseGet(operation);
  var url = operation.context.url;

  if (!useGETMethod || !body) {
    return url;
  }

  var search = [];

  if (body.operationName) {
    search.push('operationName=' + encodeURIComponent(body.operationName));
  }

  if (body.query) {
    search.push('query=' + encodeURIComponent(body.query.replace(/#[^\n\r]+/g, ' ').trim()));
  }

  if (body.variables) {
    search.push('variables=' + encodeURIComponent(stringifyVariables(body.variables)));
  }

  if (body.extensions) {
    search.push('extensions=' + encodeURIComponent(stringifyVariables(body.extensions)));
  }

  var finalUrl = url + "?" + search.join('&');

  if (finalUrl.length > 2047) {
    operation.context.preferGetMethod = false;
    return url;
  }

  return finalUrl;
}

function makeFetchOptions(operation, body) {
  var useGETMethod = shouldUseGet(operation);
  var headers = {
    accept: 'application/graphql+json, application/json'
  };

  if (!useGETMethod) {
    headers['content-type'] = 'application/json';
  }

  var extraOptions = (typeof operation.context.fetchOptions === 'function' ? operation.context.fetchOptions() : operation.context.fetchOptions) || {};

  if (extraOptions.headers) {
    for (var key in extraOptions.headers) {
      headers[key.toLowerCase()] = extraOptions.headers[key];
    }
  }

  return _extends({}, extraOptions, {
    body: !useGETMethod && body ? JSON.stringify(body) : undefined,
    method: useGETMethod ? 'GET' : 'POST',
    headers: headers
  });
}

var asyncIterator = typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;
var decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
var jsonHeaderRe = /content-type:[^\r\n]*application\/json/i;
var boundaryHeaderRe = /boundary="?([^=";]+)"?/i; // NOTE: We're avoiding referencing the `Buffer` global here to prevent
// auto-polyfilling in Webpack

function toString(input) {
  return input.constructor.name === 'Buffer' ? input.toString() : decoder.decode(input);
}

function makeFetchSource(operation, url, fetchOptions) {
  var maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;
  var fetcher = operation.context.fetch;
  return wonka.make(function (ref) {
    var next = ref.next;
    var complete = ref.complete;
    var abortController = typeof AbortController !== 'undefined' ? new AbortController() : null;

    if (abortController) {
      fetchOptions.signal = abortController.signal;
    }

    var hasResults = false; // DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>
    // See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts

    function executeIncrementalFetch(onResult, operation, response) {
      // NOTE: Guarding against fetch polyfills here
      var contentType = response.headers && response.headers.get('Content-Type') || '';

      if (/text\//i.test(contentType)) {
        return response.text().then(function (text) {
          onResult(makeErrorResult(operation, new Error(text), response));
        });
      } else if (!/multipart\/mixed/i.test(contentType)) {
        return response.text().then(function (payload) {
          onResult(makeResult(operation, JSON.parse(payload), response));
        });
      }

      var boundary = '---';
      var boundaryHeader = contentType.match(boundaryHeaderRe);

      if (boundaryHeader) {
        boundary = '--' + boundaryHeader[1];
      }

      var read;

      var cancel = function () {
        /*noop*/
      };

      if (asyncIterator && response[asyncIterator]) {
        var iterator = response[asyncIterator]();
        read = iterator.next.bind(iterator);
      } else if ('body' in response && response.body) {
        var reader = response.body.getReader();
        cancel = reader.cancel.bind(reader);
        read = reader.read.bind(reader);
      } else {
        throw new TypeError('Streaming requests unsupported');
      }

      var buffer = '';
      var isPreamble = true;
      var nextResult = null;
      var prevResult = null;

      function next(data) {
        if (!data.done) {
          var chunk = toString(data.value);
          var boundaryIndex = chunk.indexOf(boundary);

          if (boundaryIndex > -1) {
            boundaryIndex += buffer.length;
          } else {
            boundaryIndex = buffer.indexOf(boundary);
          }

          buffer += chunk;

          while (boundaryIndex > -1) {
            var current = buffer.slice(0, boundaryIndex);
            var next$1 = buffer.slice(boundaryIndex + boundary.length);

            if (isPreamble) {
              isPreamble = false;
            } else {
              var headersEnd = current.indexOf('\r\n\r\n') + 4;
              var headers = current.slice(0, headersEnd);
              var body = current.slice(headersEnd, current.lastIndexOf('\r\n'));
              var payload = void 0;

              if (jsonHeaderRe.test(headers)) {
                try {
                  payload = JSON.parse(body);
                  nextResult = prevResult = prevResult ? mergeResultPatch(prevResult, payload, response) : makeResult(operation, payload, response);
                } catch (_error) {}
              }

              if (next$1.slice(0, 2) === '--' || payload && !payload.hasNext) {
                if (!prevResult) {
                  return onResult(makeResult(operation, {}, response));
                }

                break;
              }
            }

            buffer = next$1;
            boundaryIndex = buffer.indexOf(boundary);
          }
        } else {
          hasResults = true;
        }

        if (nextResult) {
          onResult(nextResult);
          nextResult = null;
        }

        if (!data.done && (!prevResult || prevResult.hasNext)) {
          return read().then(next);
        }
      }

      return read().then(next).finally(cancel);
    }

    var ended = false;
    var statusNotOk = false;
    var response;
    Promise.resolve().then(function () {
      if (ended) {
        return;
      }

      return (fetcher || fetch)(url, fetchOptions);
    }).then(function (_response) {
      if (!_response) {
        return;
      }

      response = _response;
      statusNotOk = response.status < 200 || response.status >= maxStatus;
      return executeIncrementalFetch(next, operation, response);
    }).then(complete).catch(function (error) {
      if (hasResults) {
        throw error;
      }

      var result = makeErrorResult(operation, statusNotOk ? response.statusText ? new Error(response.statusText) : error : error, response);
      next(result);
      complete();
    });
    return function () {
      ended = true;

      if (abortController) {
        abortController.abort();
      }
    };
  });
}

exports.CombinedError = CombinedError;
exports._extends = _extends;
exports.createRequest = createRequest;
exports.getOperationName = getOperationName;
exports.getOperationType = getOperationType;
exports.keyDocument = keyDocument;
exports.makeErrorResult = makeErrorResult;
exports.makeFetchBody = makeFetchBody;
exports.makeFetchOptions = makeFetchOptions;
exports.makeFetchSource = makeFetchSource;
exports.makeFetchURL = makeFetchURL;
exports.makeResult = makeResult;
exports.mergeResultPatch = mergeResultPatch;
exports.stringifyDocument = stringifyDocument;
exports.stringifyVariables = stringifyVariables;
//# sourceMappingURL=3ada59d5.js.map
