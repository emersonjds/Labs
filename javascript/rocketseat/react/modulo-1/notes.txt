PROPS **
todo componente pode ter propriedades que sao colocadas quando o componente é chamado, ja na componente em si para se utilizar do valor daquela propriedade,
acessamos utilizando o "props"

Exemplo
Component Button
<Button title="Enviar" />
uso do valor dentro do componente
return <a href="#" > {this.props.title} </a>

E assim pode ser utilizado qualquer valor que for passado como propriedade para o componente

Uma outra forma de acesso a valores dos componentes é atraves da propriedade children, sempre que valores forem passados para dentro de um componente o mesmo pode ser acessado atraves desta propriedade
Exemplo
<Button> Enviar </Button>
O valor "Envar" pode ser acessado no componente por this.props.children
return <a href="#" > {this.props.children} </a>


é possivel ainda passar funções como propriedades dos componentes, o controle desta chamada de funcão pode ser feito pelo componente que esta utilizando aquele outro componente ou diretamente pelo componente quando disparado a founção.

Por exemplo, digamos que o componente App utiliza o Componente Button

<App>
  Dentro de app a uma founçã antes do render que executa algo.
  chamaNome() {
    console.log('Chama nome');
  }
  <Button onClick={this.chamaNome}></Button>
</App>

Ja no componente Button é acessado o valor da propriedade para que a função seja executada
<Button>
  return (
    <button onClick={this.props.chamaNome}></button>
    ** o componente ganha uma propriedade chamada onClick que consegue acessar o valor da função que foi passada como parametro, nao é necessario parenteses para execução isto é implicito na declaração do JSX
  )
</Button>
---------------------------------------------- // --------------------------------

PropsTypes e Default Props
Quando nao passamos diretamente valores para as propriedades dos componente, podemos setar valores padroes para eles assim que sao renderizados.
Por Exemplo o botao pode ser utilizado em varios pontos da aplicação, mas nao é necessario que sempre seja passado um title ou uma função para ele é possivel apenas chamar ele
<Button/>
<Button title="Enviar" />

Quando o botao é somente chamado podemos predefinir suas propriedades padroes utlizando o conceito de defaultProps e PropTypes
Button.defaultProps = {
  children: 'Enviar'
}
Neste caso se nao for passado nenhum valor para children, assim que o botao for renderizado ele vao inicializar com o valor Enviar nele

Para utilizar o PropTypes é necessario instalar a lib auxiliar prop-types, que permite que as propriedades sejam tipadas, sejam implicitamente setadas para que os valores sejam o mais padronizado possivel
Apos importar a biblioteca basta setar o valor das props
Button.propTypes = {
  onClick: PropTypes.func.isRequired
};
Neste caso a propriedade onClick é do tipo Função é ela é requirida, ja que a declaração é sempre um Button

Para que estes valores possam ser declarados diretamente na classe, é possivel utilizar um plugin do babel que deixa que as props e default props sejam declaradas dentro com componente como metodos estaticos
para isso basta utilizar o @babel/proposal-class-properties e setar seu conteudo no babelrc na area de plugins

----------------------------- // --------------------------------------

STATE AND IMMUTABILITY
Basicamente o estado é uma variavel que fica dentro do componente e contem todas as informações que podem ser manipuladas por esse componente. O state sempre é um objeto.
No react utiliza-se muito o conceito de imutabilidade, desta forma nao é possivel setar o valor do estado diretamente com VanillaJS, é necessario repor o valor atual com um novo valor.
Por exemplo, supondo que ao clicar num botao um valor sera atualizado, a função que faz essa manipulação nao pode simplismente setar o valor do estado com ++

state = {
  counter: 0,
}

//errado
fn() {
  this.state.counter++;
}

//certo
fn() {
  this.setState({
    counter: this.state.counter + 1
  })
}

Desta forma o valor sera alterado porem sem usar diretamente o state .
Se a founçã for declarada como fn e corpo o this ira se referenciar ao escopo da função
O ideal é sempre utilizar arrow functions nas classes em react

fn = () => {}

**Nota
Toda vez que o valor do state é alterado ou alguma propriedade sofre alteração o metodo render do componente é executado novamente, isso é padrao, ele sempre sera rerenderizado

*Nota
A função setState é tratada de forma assincrona quando executada, se encadeado duas chamadas setState, o react utiliza um processo de fila para armazenadar os valores do state da class e os valores do state que sera ajustado no setState, por exemplo

state = {
  counter: 0
}

Quando setState for chamado para mudar aquele valor ...
this.setState({
  counter: this.state.counter + 1
})
a chamada do setState demora alguns mili segundos a mais do que o render ja que existe a fila de funções que esta sendo executada em sequencia com o High Order Functions .... desta forma caso seja necessario ja utilizar o retorno deste valor é necessario utilizar um callback para entender o valor atual do setState ...
this.setState({counter: this.state.counter +1}, () => {
  neste ponto o retorno do primeiro parametro fica em memoria e é jogado para este callback que pode executar uma outra ...
})

Uma outra forma de utilizar isto seria declarando uma variavel de referencia assim que o setState é chamado, esta variavel, indica o valor atual do state na fila de High Orders ...
deste forma ...
this.setState(state => ({counter: state.counter + 1}))
O valor de state neste caso é o valor de execução direto da fila de operações.

---------------------------------------- // ----------------------------------------

STATELESS X STATEFULL
Tratando de boas praticas, no react o ideal é ter apenas um componente por arquivo, isso facilita na manutenção da aplicação.
Alguns pontos...
O nome do arquivo .js que for criado sempre deve ir de encontro com o nome da classe que sera criada
Button.js ... class Button ....

A diferença entre stateless vs statefull é que componente stateless nao possuem estados, desta forma no momento em que for declarado, ele é declarado em forma de constante ...
Exemplo

const Button = (props) => ()
Utiliza-se parenteses e nao chaves por que a função ja ira retornar estrutura JSX , isso tambem pode ser utilizado nas chamadas de pontos de classe para executar determinada lógica.
Para se ter acesso as props que sao passadas na chamada deste componente, esta constante recebe como parametro as props , que podem ser utilizadas posteriormente dentro do componente.
Um outro ponto a se atentar é que no final do arquivo deve-se exportar essa constante para que outros componentes possam importa-lo.
A parte de prop-types tambem é utilizada de maneira externa dentro do arquivo.
Por exemplo

Button.defaultProps = {} ....
Button.propTypes = {} ...

Ja componentes que vao possuir estados, o ideal é que sejam declarados como classes, utilizando os metodos padroes de acesso


------------------------------------------------ // --------------------------------

CICLO DE VIDA DE COMPONENTES
Os ciclos de vida sao semelhantes aos ja implementados no Angular, com inicialização , apos efetuar determinada ação e ou o componente ser destruido.

componentDidMount() {} -> executado automaticamente na inicialização do componente, muito utilizado para trabalhar com request e busca de dados , cadastrar eventos listeners.

componentWillUnmount() {} -> esse metodo é executado quando o componente deixa de existir na aplicação, geralmente é utilizado para limpar listeners que tenham sido criados no componentDidMount.

shouldComponentUpdate(nextProps, nextState) {} -> Esse metodo é executado toda vez que alguma propriedade ou estado do component é alterada, é possivel controlar a atualização destas informações diretamente com esse metodo.
Por exemplo
state = {
  counter: 0
}

Digamos que o state sofra algum tipo de alteração e que por padrao a aplicação so possa mostrar valores do counter até 10, chamando o metodo shouldComponentUpdate(nextProps, nextState) é possivel controlar isso
shouldComponentUpdate(nextProps, nextState) {
  return nextState.counter <= 10;
  com isso o contador ira parar no valor 10 na tela, o state em si continuara sendo incrementado porem o render nao é mas executado por que o shouldComponentUpdate consegue controlar o que renderiza e o que nao renderiza na atualização de informaçoes
}

componentDidUpdate(prevProps, prevState) {} -> executado depois que algum estado ou propriedade sofre alguma alteração ja ter ocorrido, apos o render ter sido executado

------------------------------------------ // --------------------------------------------------

ESTILOS NO REACT
Para que o javascript entenda os estilos que estao sendo passados no componente, é necessario o carregamento de libs externas e confifuração das mesmas no Webpack, no caso de eostilizaçã pode-ser utilizar a style-loader e css-loader , como dependencias de desenvolvimento
Para utilizar o sass , basta utilizar o sass-loader e o node-sass
A utilização de classes css no componente é chamado por className e é possivel ainda utilizar estilos inline

---------------------------------------//-------------------------------------------
Patterns
É importante sempre utilizar padroes nos projetos em React, um dos modelos mais utilizados é o eslint do Airbnb
que pode ser configurado instalando a lib eslint como devDependencies
para executar basta executar o comando --init em node_modules/.bin/eslint e escolher o guia Airbnb com formato JSON


