"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
let DaemonCommand = class DaemonCommand extends cli_utils_1.Command {
    run(inputs, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const updateInterval = Number(options.interval);
            const killExisting = options['kill-existing'];
            const config = yield this.env.config.load();
            if (!config.daemon.updates) {
                this.env.log.info('Daemon is disabled.');
                return 1;
            }
            const f = yield this.env.daemon.getPid();
            const d = yield this.env.daemon.load();
            d.daemonVersion = this.env.plugins.ionic.version;
            if (f) {
                this.env.log.info(`Daemon pid file found: ${chalk.bold(cli_utils_1.prettyPath(this.env.daemon.pidFilePath))}`);
                if (killExisting) {
                    this.env.log.info(`Killing existing daemon process ${chalk.bold(String(f))}.`);
                    yield cli_utils_1.fsUnlink(this.env.daemon.pidFilePath);
                    process.kill(Number(f));
                }
                else if (!cli_utils_1.processRunning(f)) {
                    this.env.log.info(`Process ${chalk.bold(String(f))} not found, deleting pid file.`);
                    yield cli_utils_1.fsUnlink(this.env.daemon.pidFilePath);
                }
                else {
                    this.env.log.info('Daemon already running and up-to-date.');
                    return 0;
                }
            }
            this.env.log.info(`Writing ${chalk.bold(String(process.pid))} to daemon pid file (${chalk.bold(cli_utils_1.prettyPath(this.env.daemon.pidFilePath))}).`);
            yield this.env.daemon.setPid(process.pid);
            const updateFn = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = yield this.env.config.load({ disk: true });
                const f = yield this.env.daemon.getPid();
                const d = yield this.env.daemon.load({ disk: true });
                const ionicDistTag = cli_utils_1.determineDistTag(d.daemonVersion);
                const latestDistTagVersion = typeof d.latestVersions[ionicDistTag] === 'undefined' ? d.daemonVersion : d.latestVersions[ionicDistTag].ionic;
                if (!f) {
                    this.env.log.info(`Daemon shutting down--pid file missing.`);
                    return process.exit();
                }
                else if (f !== process.pid) {
                    this.env.log.info(`Daemon shutting down--mismatch with pid file. (${chalk.bold(String(f))} vs ${chalk.bold(String(process.pid))})`);
                    return process.exit();
                }
                else if (!config.daemon.updates) {
                    this.env.log.info(`Daemon shutting down--daemon was disabled.`);
                    return process.exit();
                }
                else if (yield cli_utils_1.pluginHasUpdate(d.daemonVersion, latestDistTagVersion)) {
                    this.env.log.info(`Daemon shutting down--out-of-date. (${chalk.bold(d.daemonVersion)} vs ${chalk.bold(latestDistTagVersion)})`);
                    return process.exit();
                }
                for (let distTag in d.latestVersions) {
                    const pkgs = Object.keys(d.latestVersions[distTag]);
                    const pkgUpdates = yield Promise.all(pkgs.map(pkg => cli_utils_1.pkgLatestVersion(this.env, pkg, distTag)));
                    for (let i in pkgUpdates) {
                        d.latestVersions[distTag][pkgs[i]] = pkgUpdates[i] || '';
                    }
                }
                this.env.log.info('Writing daemon file.');
                yield this.env.daemon.save();
            });
            const cleanup = () => {
                try {
                    const fs = require('fs');
                    fs.unlinkSync(this.env.daemon.pidFilePath);
                }
                catch (e) {
                    if (e.code !== 'ENOENT') {
                        throw e;
                    }
                }
                process.exit();
            };
            process.on('exit', cleanup);
            process.on('SIGINT', cleanup);
            process.on('SIGTERM', cleanup);
            process.on('SIGHUP', cleanup);
            process.on('SIGBREAK', cleanup);
            const delayMs = 5 * 1000; // wait 5 seconds before doing first check
            const updateIntervalMs = updateInterval * 1000; // check every interval
            setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield updateFn();
                setInterval(updateFn, updateIntervalMs);
            }), delayMs);
        });
    }
};
DaemonCommand = tslib_1.__decorate([
    cli_utils_1.CommandMetadata({
        name: 'daemon',
        type: 'global',
        description: 'Ionic update checker daemon',
        options: [
            {
                name: 'interval',
                description: 'Interval, in seconds, to check for updates',
                default: '900',
            },
            {
                name: 'kill-existing',
                description: 'If an existing daemon is found, force kill it',
                type: Boolean,
            },
        ],
        visible: false,
    })
], DaemonCommand);
exports.DaemonCommand = DaemonCommand;
